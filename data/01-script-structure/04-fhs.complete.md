## Filesystem Hierarchy Standard (FHS) Preference

**When designing scripts that install files or search for resources, follow the Filesystem Hierarchy Standard (FHS) where practical. FHS compliance enables predictable file locations, supports both system and user installations, and integrates smoothly with package managers.**

**Rationale:**

- **Predictability**: Users and package managers expect files in standard locations (`/usr/local/bin/`, `/usr/share/`, etc.)
- **Multi-Environment Support**: Scripts work correctly in development, local install, system install, and user-specific install scenarios
- **Package Manager Compatibility**: FHS-compliant layouts work seamlessly with apt, yum, pacman, etc.
- **No Hardcoded Paths**: Using FHS search patterns eliminates brittle absolute paths
- **Portability**: Scripts work across different Linux distributions without modification
- **Separation of Concerns**: FHS separates executables, data, configuration, and documentation logically

**Common FHS locations:**
- `/usr/local/bin/` - User-installed executables (system-wide, not managed by package manager)
- `/usr/local/share/` - Architecture-independent data files
- `/usr/local/lib/` - Libraries and loadable modules
- `/usr/local/etc/` - Configuration files
- `/usr/bin/` - System executables (managed by package manager)
- `/usr/share/` - System-wide architecture-independent data
- `$HOME/.local/bin/` - User-specific executables (in user's PATH)
- `$HOME/.local/share/` - User-specific data files
- `${XDG_CONFIG_HOME:-$HOME/.config}/` - User-specific configuration

**When FHS is useful:**
- Installation scripts that need to place files in standard locations
- Scripts that search for data files in multiple standard locations
- Scripts that support both system-wide and user-specific installation
- Projects distributed to multiple systems expecting standard paths

**Example pattern - searching for data files:**
```bash
find_data_file() {
  local -- script_dir=$1
  local -- filename=$2
  local -a search_paths=(
    "$script_dir"/"$filename"  # Same directory (development)
    /usr/local/share/myapp/"$filename" # Local install
    /usr/share/myapp/"$filename" # System install
    "${XDG_DATA_HOME:-"$HOME"/.local/share}"/myapp/"$filename"  # User install
  )

  local -- path
  for path in "${search_paths[@]}"; do
    [[ -f "$path" ]] && { echo "$path"; return 0; } ||:
  done

  return 1
}
```

**Complete installation example (Makefile pattern):**

```bash
#!/bin/bash
# install.sh - FHS-compliant installation script
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

declare -r VERSION=1.0.0
#shellcheck disable=SC2155
declare -r SCRIPT_PATH=$(realpath -- "$0")
declare -r SCRIPT_DIR=${SCRIPT_PATH%/*} SCRIPT_NAME=${SCRIPT_PATH##*/}

# Installation paths (customizable via PREFIX)
declare -- PREFIX=${PREFIX:-/usr/local}
declare -- BIN_DIR="$PREFIX"/bin
declare -- SHARE_DIR="$PREFIX"/share/myapp
declare -- LIB_DIR="$PREFIX"/lib/myapp
declare -- ETC_DIR="$PREFIX"/etc/myapp
declare -- MAN_DIR="$PREFIX"/share/man/man1
readonly -- PREFIX BIN_DIR SHARE_DIR LIB_DIR ETC_DIR MAN_DIR

install_files() {
  # Create directories
  install -d "$BIN_DIR"
  install -d "$SHARE_DIR"
  install -d "$LIB_DIR"
  install -d "$ETC_DIR"
  install -d "$MAN_DIR"

  # Install executable
  install -m 755 "$SCRIPT_DIR"/myapp "$BIN_DIR"/myapp

  # Install data files
  install -m 644 "$SCRIPT_DIR"/data/template.txt "$SHARE_DIR"/template.txt

  # Install libraries
  install -m 644 "$SCRIPT_DIR"/lib/common.sh "$LIB_DIR"/common.sh

  # Install configuration (preserve existing)
  if [[ ! -f "$ETC_DIR"/myapp.conf ]]; then
    install -m 644 "$SCRIPT_DIR"/myapp.conf.example "$ETC_DIR"/myapp.conf
  fi

  # Install man page
  install -m 644 "$SCRIPT_DIR"/docs/myapp.1 "$MAN_DIR"/myapp.1

  info "Installation complete to $PREFIX"
  info "Executable: $BIN_DIR/myapp"
}

uninstall_files() {
  # Remove installed files
  rm -f "$BIN_DIR"/myapp
  rm -f "$SHARE_DIR"/template.txt
  rm -f "$LIB_DIR"/common.sh
  rm -f "$MAN_DIR"/myapp.1

  # Remove directories if empty
  rmdir --ignore-fail-on-non-empty "$SHARE_DIR"
  rmdir --ignore-fail-on-non-empty "$LIB_DIR"
  rmdir --ignore-fail-on-non-empty "$ETC_DIR"

  info 'Uninstallation complete'
}

main() {
  case "${1:-install}" in
    install)   install_files ;;
    uninstall) uninstall_files ;;
    *)         die 2 "Usage: $SCRIPT_NAME {install|uninstall}" ;;
  esac
}

main "$@"

#fin
```

**FHS-aware resource loading pattern:**

```bash
#!/bin/bash
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

declare -r VERSION=1.0.0
#shellcheck disable=SC2155
declare -r SCRIPT_PATH=$(realpath -- "$0")
declare -r SCRIPT_DIR=${SCRIPT_PATH%/*} SCRIPT_NAME=${SCRIPT_PATH##*/}

# Find data file using FHS search pattern
find_data_file() {
  local -- filename=$1
  local -a search_paths=(
    # Development: same directory as script
    "$SCRIPT_DIR"/"$filename"

    # Local install: /usr/local/share
    /usr/local/share/myapp/"$filename"

    # System install: /usr/share
    /usr/share/myapp/"$filename"

    # User install: XDG Base Directory
    "${XDG_DATA_HOME:-"$HOME"/.local/share}"/myapp/"$filename"
  )

  local -- path
  for path in "${search_paths[@]}"; do
    if [[ -f "$path" ]]; then
      echo "$path"
      return 0
    fi
  done

  die 2 "Data file not found ${filename@Q}"
}

# Find configuration file with XDG support
find_config_file() {
  local -- filename=$1
  local -a search_paths=(
    # User-specific config (highest priority)
    "${XDG_CONFIG_HOME:-"$HOME"/.config}"/myapp/"$filename"

    # System-wide local config
    /usr/local/etc/myapp/"$filename"

    # System-wide config
    /etc/myapp/"$filename"

    # Development/fallback
    "$SCRIPT_DIR"/"$filename"
  )

  local -- path
  for path in "${search_paths[@]}"; do
    [[ ! -f "$path" ]] || { echo "$path"; return 0; }
  done

  # Return empty if not found (config is optional)
  return 1
}

# Load library from FHS locations
load_library() {
  local -- lib_name=$1
  local -a search_paths=(
    # Development
    "$SCRIPT_DIR"/lib/"$lib_name"

    # Local install
    /usr/local/lib/myapp/"$lib_name"

    # System install
    /usr/lib/myapp/"$lib_name"
  )

  local -- path
  for path in "${search_paths[@]}"; do
    [[ -f "$path" ]] && { source "$path"; return 0; } ||:
  done

  die 2 "Library not found ${lib_name@Q}"
}

main() {
  # Load required library
  load_library common.sh

  # Find data file
  local -- template
  template=$(find_data_file template.txt)
  info "Using template ${template@Q}"

  # Find config file (optional)
  local -- config
  if config=$(find_config_file myapp.conf); then
    info "Loading config ${config@Q}"
    source "$config"
  else
    info 'No config file found, using defaults'
  fi

  # Main logic here
  #...
}

main "$@"
#fin
```

**PREFIX customization (make install pattern):**

```bash
# Makefile example
PREFIX ?= /usr/local
BINDIR = $(PREFIX)/bin
SHAREDIR = $(PREFIX)/share/myapp
MANDIR = $(PREFIX)/share/man/man1

install:
	install -d $(BINDIR)
	install -d $(SHAREDIR)
	install -d $(MANDIR)
	install -m 755 myapp $(BINDIR)/myapp
	install -m 644 data/template.txt $(SHAREDIR)/template.txt
	install -m 644 docs/myapp.1 $(MANDIR)/myapp.1

uninstall:
	rm -f $(BINDIR)/myapp
	rm -f $(SHAREDIR)/template.txt
	rm -f $(MANDIR)/myapp.1

# Usage:
# make install                      # Installs to /usr/local
# make PREFIX=/usr install          # Installs to /usr
# make PREFIX=$HOME/.local install  # User install
```

**XDG Base Directory Specification:**

For user-specific files, follow XDG Base Directory spec:

```bash
# XDG environment variables with fallbacks
declare -- XDG_DATA_HOME=${XDG_DATA_HOME:-"$HOME"/.local/share}
declare -- XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-"$HOME"/.config}
declare -- XDG_CACHE_HOME=${XDG_CACHE_HOME:-"$HOME"/.cache}
declare -- XDG_STATE_HOME=${XDG_STATE_HOME:-"$HOME"/.local/state}

# User-specific paths
declare -- USER_DATA_DIR="$XDG_DATA_HOME"/myapp
declare -- USER_CONFIG_DIR="$XDG_CONFIG_HOME"/myapp
declare -- USER_CACHE_DIR="$XDG_CACHE_HOME"/myapp
declare -- USER_STATE_DIR="$XDG_STATE_HOME"/myapp

# Create user directories if needed
install -d "$USER_DATA_DIR"
install -d "$USER_CONFIG_DIR"
install -d "$USER_CACHE_DIR"
install -d "$USER_STATE_DIR"
```

**Production-Ready Templates (Copy-Paste Ready):**

These templates are extracted from the `bcs` script itself and demonstrate production-tested FHS compliance patterns. Adapt by replacing `yatti/bash-coding-standard` with your organization/project name.

**Template 1: Find File in FHS Locations**

This template searches for a specific file across all standard FHS locations, supporting development mode, custom PREFIX installs, system-local, and system-wide installations.

```bash
# Find specific file (e.g., BASH-CODING-STANDARD.md, config.yml, data.json)
# Usage: bcs_file=$(find_bcs_file "$SCRIPT_DIR") || die 'File not found'
find_bcs_file() {
  local -- script_dir=$1
  local -- install_share="${script_dir%/bin}"/share/yatti/bash-coding-standard
  local -a search_paths=(
    "$script_dir"                                 # Development: same directory
    "$install_share"                              # Custom PREFIX: relative to bin/
    /usr/local/share/yatti/bash-coding-standard   # System-local install
    /usr/share/yatti/bash-coding-standard         # System-wide install
  )
  local -- path
  for path in "${search_paths[@]}"; do
    if [[ -f "$path"/BASH-CODING-STANDARD.md ]]; then
      echo "$path"/BASH-CODING-STANDARD.md
      return 0
    fi
  done

  return 1
}
declare -fx find_bcs_file

# Usage example:
BCS_FILE=$(find_bcs_file "$SCRIPT_DIR") || die 1 'BASH-CODING-STANDARD.md not found'
```

**Key features of this template:**
- **`install_share` calculation**: Dynamically computes share directory from bin directory using `${script_dir%/bin}/share/...`
- **Four search locations**: Development, custom PREFIX, /usr/local, /usr
- **Early return on found**: Uses `&& { echo ...; return 0; }` for immediate success
- **Export**: Uses `declare -fx` for use in subshells if needed

**Adaptation guide:**
```bash
# Replace 'yatti/bash-coding-standard' with your org/project:
install_share="${script_dir%/bin}"/share/myorg/myproject
/usr/local/share/myorg/myproject
/usr/share/myorg/myproject

# Replace 'BASH-CODING-STANDARD.md' with your target file:
[[ -f "$path"/config.yml ]] && { echo "$path"/config.yml; return 0; }

# Rename function to match purpose:
find_config_file() { ... }
find_template_file() { ... }
```

**Template 2: Find Data Directory**

This template finds the data directory itself (rather than a specific file), useful for scripts that need to enumerate or access multiple files within the data directory.

```bash
# Find data directory in FHS locations
# Usage: data_dir=$(find_data_dir) || die 'Data directory not found'
find_data_dir() {
  local -- install_share="${BCS_DIR%/bin}/share/yatti/bash-coding-standard/data"
  local -a search_paths=(
    "$BCS_DIR"/data                                   # Development mode
    "$install_share"                                  # Custom PREFIX install
    /usr/local/share/yatti/bash-coding-standard/data  # System-local install
    /usr/share/yatti/bash-coding-standard/data        # System-wide install
  )
  local -- path
  for path in "${search_paths[@]}"; do
    [[ -d "$path" ]] && { echo "$path"; return 0; } ||:
  done

  return 1
}
declare -fx find_data_dir

# Usage example:
DATA_DIR=$(find_data_dir) || die 1 'Data directory not found'
```

**Differences from Template 1:**
- **Directory check**: Uses `[[ -d "$path" ]]` instead of `[[ -f ... ]]`
- **Returns directory**: Echoes directory path, not file path
- **Enables enumeration**: Caller can then use `find "$DATA_DIR" ...` or `for file in "$DATA_DIR"/*.md`

**Usage patterns:**
```bash
# Pattern 1: Find and enumerate files
DATA_DIR=$(find_data_dir) || die 1 'Data directory not found'
readarray -t md_files < <(find "$DATA_DIR" -name '*.md' | sort)

# Pattern 2: Check for specific files in data directory
DATA_DIR=$(find_data_dir) || die 1 'Data directory not found'
[[ -f "$DATA_DIR"/templates/basic.sh ]] || die 1 'Template not found'

# Pattern 3: Iterate over data files
DATA_DIR=$(find_data_dir) || die 1 'Data directory not found'
for file in "$DATA_DIR"/*.json; do
  process_json "$file"
done
```

**Combined Template: Universal FHS Resource Finder**

For maximum flexibility, combine both patterns into a generic resource finder:

```bash
# Generic FHS resource finder
# Usage: find_resource file "config.yml" || die 'Config not found'
# Usage: find_resource dir "data" || die 'Data directory not found'
find_resource() {
  local -- type=$1     # 'file' or 'dir'
  local -- name=$2     # Resource name
  local -- install_base="${SCRIPT_DIR%/bin}"/share/myorg/myproject
  local -a search_paths=(
    "$SCRIPT_DIR"                        # Development
    "$install_base"                      # Custom PREFIX
    /usr/local/share/myorg/myproject     # Local install
    /usr/share/myorg/myproject           # System install
  )

  local -- path
  for path in "${search_paths[@]}"; do
    local -- resource="$path/$name"
    case "$type" in
      file) [[ -f "$resource" ]] && { echo "$resource"; return 0; } ||: ;;
      dir)  [[ -d "$resource" ]] && { echo "$resource"; return 0; } ||: ;;
      *)    die 2 "Invalid resource type ${type@Q}" ;;
    esac
  done

  return 1
}
declare -fx find_resource

# Usage:
CONFIG=$(find_resource file config.yml) || die 'Config not found'
DATA_DIR=$(find_resource dir data) || die 'Data directory not found'
TEMPLATE=$(find_resource file templates/basic.sh) || die 'Template not found'
```

**Real-world example from this repository:**

The actual `bash-coding-standard` (bcs) script uses these exact patterns (lines 137-171 in bcs). Here's the simplified version showing the file search:

```bash
find_bcs_file() {
  local -a search_paths=(
    # Development: same directory as script
    "$SCRIPT_DIR"/BASH-CODING-STANDARD.md

    # Local install: /usr/local/share
    /usr/local/share/yatti/bash-coding-standard/BASH-CODING-STANDARD.md

    # System install: /usr/share
    /usr/share/yatti/bash-coding-standard/BASH-CODING-STANDARD.md
  )

  local -- path
  for path in "${search_paths[@]}"; do
    [[ -f "$path" ]] && { echo "$path"; return 0; } ||:
  done

  die 2 'BASH-CODING-STANDARD.md not found in any standard location'
}

BCS_FILE=$(find_bcs_file)
```

This approach allows the script to work in:
- Development mode (running from source directory)
- After `make install` (to /usr/local)
- After `make PREFIX=/usr install` (system-wide)
- When installed by package manager (debian, rpm, etc.)

**Anti-patterns to avoid:**

```bash
# ✗ Wrong - hardcoded absolute path
data_file=/home/user/projects/myapp/data/template.txt

# ✓ Correct - FHS search pattern
data_file=$(find_data_file template.txt)

# ✗ Wrong - assuming specific install location
source /usr/local/lib/myapp/common.sh

# ✓ Correct - search multiple FHS locations
load_library common.sh

# ✗ Wrong - using relative paths from CWD
source ../lib/common.sh  # Breaks when run from different directory

# ✓ Correct - paths relative to script location
source "$SCRIPT_DIR"/../lib/common.sh

# ✗ Wrong - installing to non-standard location
install myapp /opt/random/location/bin/

# ✓ Correct - use PREFIX-based FHS paths
install myapp "$PREFIX"/bin/

# ✗ Wrong - not supporting PREFIX customization
BIN_DIR=/usr/local/bin  # Hardcoded

# ✓ Correct - respect PREFIX environment variable
PREFIX=${PREFIX:-/usr/local}
BIN_DIR="$PREFIX"/bin

# ✗ Wrong - mixing executables and data in same directory
install myapp /opt/myapp/
install template.txt /opt/myapp/

# ✓ Correct - separate by FHS hierarchy
install myapp "$PREFIX"/bin/
install template.txt "$PREFIX"/share/myapp/

# ✗ Wrong - overwriting user configuration on upgrade
install myapp.conf "$PREFIX"/etc/myapp/myapp.conf

# ✓ Correct - preserve existing config
[[ -f "$PREFIX"/etc/myapp/myapp.conf ]] || \
  install myapp.conf.example "$PREFIX"/etc/myapp/myapp.conf
```

**Edge cases:**

**1. PREFIX with trailing slash:**

```bash
# Handle PREFIX with or without trailing slash
PREFIX=${PREFIX:-/usr/local}
PREFIX=${PREFIX%/}  # Remove trailing slash if present
BIN_DIR="$PREFIX"/bin
```

**2. User install without sudo:**

```bash
# Detect if user has write permissions
if [[ ! -w "$PREFIX" ]]; then
  warn "No write permission to ${PREFIX@Q}"
  info "Try: PREFIX=\$HOME/.local make install"
  die 5 'Permission denied'
fi
```

**3. Library path for runtime:**

```bash
# Some systems need LD_LIBRARY_PATH for custom locations
if [[ -d "$PREFIX"/lib/myapp ]]; then
  export LD_LIBRARY_PATH="$PREFIX"/lib/myapp"${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
fi
```

**4. Symlink vs real path:**

```bash
# If script is symlinked to /usr/local/bin, SCRIPT_DIR resolves to actual location
# This is correct - we want the real installation directory, not the symlink location
SCRIPT_PATH=$(realpath -- "$0")  # Resolves symlinks
SCRIPT_DIR=${SCRIPT_PATH%/*}

# Now SCRIPT_DIR points to actual install location, not /usr/local/bin
```

**When NOT to use FHS:**

- **Single-user scripts**: Scripts only used by one user don't need FHS
- **Project-specific tools**: Build scripts, test runners that stay in project directory
- **Container applications**: Docker containers often use app-specific paths like `/app`
- **Embedded systems**: Limited systems may use custom layouts

**Summary:**

- **Follow FHS** for scripts that install system-wide or distribute to users
- **Use PREFIX** to support custom installation locations
- **Search multiple locations** for resources (development, local, system, user)
- **Separate file types**: bin/ for executables, share/ for data, etc/ for config, lib/ for libraries
- **Support XDG** for user-specific files (`XDG_CONFIG_HOME`, `XDG_DATA_HOME`)
- **Preserve user config** on upgrades (don't overwrite existing files)
- **Make PREFIX customizable** via environment variable

**Key principle:** FHS compliance makes scripts portable, predictable, and compatible with package managers. Design scripts to work in development mode and multiple install scenarios without modification.
