#!/bin/bash
#shellcheck disable=SC1091
# mdheaders - CLI tool for manipulating markdown header levels
# Usage: mdheaders {upgrade|downgrade|normalize} [OPTIONS] FILE

set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob

# Script Metadata
declare -r VERSION='1.0.0'
#shellcheck disable=SC2155
declare -r SCRIPT_PATH=$(realpath -e -- "$0")
declare -r SCRIPT_DIR=${SCRIPT_PATH%/*} SCRIPT_NAME=${SCRIPT_PATH##*/}

declare -i VERBOSE=1

# Standard colors - only if terminal output
if [[ -t 1 && -t 2 ]]; then
  declare -r RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' NC=$'\033[0m'
else
  declare -r RED='' GREEN='' YELLOW='' CYAN='' NC=''
fi

# Core message function using FUNCNAME for context
_msg() {
  local -- prefix="$SCRIPT_NAME:" msg
  case "${FUNCNAME[1]}" in
    success) prefix+=" ${GREEN}✓${NC}" ;;
    warn)    prefix+=" ${YELLOW}▲${NC}" ;;
    info)    prefix+=" ${CYAN}◉${NC}" ;;
    error)   prefix+=" ${RED}✗${NC}" ;;
    *)       ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}

# Conditional output based on verbosity
success() { ((VERBOSE)) || return 0; _msg "$@"; }
warn() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
info() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }

# Unconditional output
error() { >&2 _msg "$@"; }
die() { (($# > 1)) && error "${@:2}"; exit "${1:-0}"; }

# Validate option has argument
noarg() { (($# > 1)) || die 2 "Option ${1@Q} requires an argument"; }

remblanks() { grep -v '^[[:blank:]]*#\|^[[:blank:]]*$'; }

# Source the library
#shellcheck source=libmdheaders.bash
source "$SCRIPT_DIR"/libmdheaders.bash

# Display usage information
show_usage() {
  cat <<'EOF'
Usage: mdheaders {upgrade|downgrade|normalize|up|down|norm} [OPTIONS] FILE

Modify markdown header levels while preserving code blocks.

Commands:
  upgrade, up         Increase header levels (# → ##)
  downgrade, down     Decrease header levels (## → #)
  normalize, norm     Normalize minimum header to specified level

Options:
  -l, --levels=N         Number of levels to shift (default: 1)
  -s, --start-level=N    Target starting level for normalize (default: 1)
  -o, --output=FILE      Output file (default: stdout)
  -i, --in-place         Modify file in-place
  -b, --backup[=SUFFIX]  Create backup before in-place edit (default: .bak)
  --skip-errors          Skip invalid headers with warning (default)
  --stop-on-error        Abort on first invalid header
  -q, --quiet            Suppress warnings and progress messages
  -v, --verbose          Show detailed processing information
  -V, --version          Show version
  -h, --help             Show this help message

Examples:
  mdheaders upgrade README.md
  mdheaders down -l 2 -ib README.md
  mdheaders up -l 1 -o NEW.md README.md
  mdheaders normalize --start-level=2 README.md
  mdheaders norm -s 2 -ib README.md
  mdheaders up -qib README.md

Exit codes:
  0  Success
  1  Error or all headers skipped
  2  Invalid arguments

EOF
}

# Main function
main() {
  # Default values
  local -- command=''
  local -i levels=1
  local -i start_level=1
  local -- output_file=''
  local -i in_place=0
  local -- backup_suffix=''
  local -- error_mode='skip'
  local -i quiet=0
  local -- input_file=''

  # Parse command
  if (($# == 0)); then
    show_usage
    return 2
  fi

  case $1 in
    upgrade|up)
      command='upgrade'
      shift
      ;;
    downgrade|down)
      command='downgrade'
      shift
      ;;
    normalize|norm)
      command='normalize'
      shift
      ;;
    -V|--version)
      echo "$SCRIPT_NAME $VERSION"; return 0
      ;;
    -h|--help|help)
      show_usage; return 0
      ;;
    *)
      die 2 "Unknown command ${1@Q}" 'Use --help for usage information'
      ;;
  esac

  # Parse options
  while (($#)); do case $1 in
    -l|--levels)
      noarg "$@"; shift; levels="$1"
      ;;
    --levels=*)
      levels="${1#*=}"
      ;;
    -s|--start-level)
      noarg "$@"; shift; start_level="$1"
      ;;
    --start-level=*)
      start_level="${1#*=}"
      ;;
    -o|--output)
      noarg "$@"; shift; output_file="$1"
      ;;
    --output=*)
      output_file="${1#*=}"
      ;;
    -i|--in-place)
      in_place=1
      ;;
    -b|--backup)
      backup_suffix='.bak'
      ;;
    --backup=*)
      backup_suffix="${1#*=}"
      ;;
    --skip-errors)
      error_mode='skip'
      ;;
    --stop-on-error)
      error_mode='stop'
      ;;
    -q|--quiet)
      quiet=1
      ;;
    -v|--verbose)
      quiet=0
      ;;
    -V|--version)
      echo "$SCRIPT_NAME $VERSION"; exit 0
      ;;
    -h|--help)
      show_usage; return 0
      ;;
    -[ibqvVh]*) #shellcheck disable=SC2046 #split up bundled short options
      set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}"
      ;;
    -*)
      die 2 "Unknown option ${1@Q}"
      ;;
    '')
      # Skip empty argument from option bundling
      ;;
    *)
      if [[ -z "$input_file" ]]; then
        input_file="$1"
      else
        die 2 "Multiple input files specified ${1@Q}"
      fi
      ;;
  esac; shift; done

  # Validate arguments
  [[ -n "$input_file" ]] || die 2 'No input file specified'
  [[ -f "$input_file" ]] || die 1 "File not found ${input_file@Q}"
  ((levels >= 1)) || die 2 'Levels must be >= 1'
  ((in_place && ${#output_file} > 0)) && die 2 'Cannot use both --in-place and --output'

  # Create backup if requested and doing in-place edit
  if ((in_place && ${#backup_suffix} > 0)); then
    local -- backup_file="${input_file}${backup_suffix}"
    cp "$input_file" "$backup_file" || die 1 'Failed to create backup file'
    ((quiet)) || info "Created backup ${backup_file@Q}"
  fi

  # Process the file
  local -- temp_file=""
  temp_file=$(mktemp) || die 1 'Failed to create temporary file'
  trap 'rm -f "${temp_file:-}"' EXIT

  local -i result=0
  if [[ "$command" == "upgrade" ]]; then
    mdh_upgrade "$levels" "$error_mode" "$quiet" < "$input_file" > "$temp_file" || result=$?
  elif [[ "$command" == "downgrade" ]]; then
    mdh_downgrade "$levels" "$error_mode" "$quiet" < "$input_file" > "$temp_file" || result=$?
  elif [[ "$command" == "normalize" ]]; then
    mdh_normalize "$start_level" "$error_mode" "$quiet" < "$input_file" > "$temp_file" || result=$?
  fi

  # Handle output
  if ((result == 0)); then
    if ((in_place)); then
      mv "$temp_file" "$input_file" || die 1 "Failed to write output file ${input_file@Q}"
      ((quiet)) || info "Modified ${input_file@Q} in-place"
    elif [[ -n "$output_file" ]]; then
      mv "$temp_file" "$output_file" || die 1 "Failed to write output file ${output_file@Q}"
      ((quiet)) || info "Wrote output to ${output_file@Q}"
    else
      cat "$temp_file"
    fi
  fi

  return "$result"
}

main "$@"
#fin
