#!/bin/bash
#shellcheck disable=SC2015
# Display the Bash Coding Standard document with optional markdown rendering
# This script can be executed directly or sourced to provide display_BCS function

# BCS Metadata
#shellcheck disable=SC2155
[[ -v BCS_VERSION ]] || {
  declare -x VERSION='1.0.0'
  declare -rx BCS_VERSION='1.0.0'
  declare -rx BCS_PATH=$(realpath -- "${BASH_SOURCE[0]}")
  declare -rx BCS_DIR=${BCS_PATH%/*}
  declare -rx BCS_NAME=${BCS_PATH##*/}
}

# Logging/Messaging system ------------
declare -i VERBOSE=1

# Color variables (BCS0101 Step 8, BCS0205)
# Idempotent: only initialize if not already set (test-helpers.sh may have set them)
if [[ ! -v RED ]]; then
  if [[ -t 1 && -t 2 ]]; then
    declare -rx RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' NC=$'\033[0m'
  else
    declare -rx RED='' GREEN='' YELLOW='' CYAN='' NC=''
  fi
fi
# _Core messaging function using FUNCNAME
_msg() {
  local -- prefix="$BCS_NAME:" msg
  case ${FUNCNAME[1]} in
    vecho)   ;;
    info)    prefix+=" ${CYAN}◉${NC}" ;;
    warn)    prefix+=" ${YELLOW}▲${NC}" ;;
    success) prefix+=" ${GREEN}✓${NC}" ;;
    error)   prefix+=" ${RED}✗${NC}" ;;
    *)       ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}
# Verbose output (respects VERBOSE flag)
vecho() { ((VERBOSE)) || return 0; _msg "$@"; }
# Info messages
info() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
# Warnings (non-fatal)
warn() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
# Success messages
success() { ((VERBOSE)) || return 0; >&2 _msg "$@" || return 0; }
# Error output (unconditional)
error() { >&2 _msg "$@"; }
# Exit with error
die() { (($# > 1)) && error "${@:2}"; exit "${1:-0}"; }
# Yes/no prompt
yn() {
  #((PROMPT)) || return 0
  local -- REPLY
  >&2 read -r -n 1 -p "$(2>&1 warn "${1:-'Continue?'}") y/n "
  >&2 echo
  [[ ${REPLY,,} == y ]]
}

# Pluralisers
# 's' English puraliser y/ies
# "files$(y "${#Files[@]")"
s() { (( ${1:-1} == 1 )) || echo -n 's'; }
# 'y' English puraliser y/ies
# "director$(y "${#Dirs[@]")"
y() { (( ${1:-1} == 1 )) && echo -n 'y' || echo -n 'ies'; }

arg2(){
  if ((${#@}-1<1)) || [[ "${2:0:1}" == '-' ]]; then
    die 2 "${1@Q} requires argument"
  fi
}
# Validate that $2 exists and is numeric, die with error if not
arg2_num(){
  if ((${#@}-1<1)) || [[ ! "$2" =~ ^[0-9]+$ ]]; then
    die 2 "${1@Q} requires a numeric argument"
  fi
}

# Trim leading and trailing whitespace
#shellcheck disable=SC2120  # Function works with both stdin and arguments
trim() {
  if (($#)); then
    local -- v
    if [[ $1 == '-e' ]]; then
      shift
      v=$(echo -en "$*")
    else
      v="$*"
    fi
    v="${v#"${v%%[![:blank:]]*}"}"
    echo -n "${v%"${v##*[![:blank:]]}"}"
    return 0
  fi
  if [[ ! -t 0 ]]; then
    local -- REPLY
    while IFS= read -r REPLY || [[ -n "$REPLY" ]]; do
      REPLY="${REPLY#"${REPLY%%[![:blank:]]*}"}"
      REPLY="${REPLY%"${REPLY##*[![:blank:]]}"}"
      echo "$REPLY"
    done
  fi
  return 0
}
declare -fx trim

# Sanitize text to URL/identifier-safe slugs
# See: https://github.com/Open-Technology-Foundation/post_slug
post_slug() {
  local input_str="${1:-}" sep_char="${2:--}"
  local -i preserve_case=${3:-0} max_len=${4:-0}
  [[ -n "$sep_char" ]] || sep_char='-'
  sep_char=${sep_char:0:1}
  (( ${#input_str} < 256 )) || input_str="${input_str:0:255}"
  input_str=$(printf '%s\n' "$input_str" | sed -e 's/—/-/g' -e 's/â�¹/Rs/g' -e 's/�/-/g' -e "s/½/$sep_char/g" -e "s/¼/$sep_char/g" -e 's/ \& / and /g' -e 's/★/ /g' -e "s/?/$sep_char/g" -e 's/€/EUR/g' -e 's/©/C/g' -e 's/®/R/g' -e 's/™/-TM/g')
  input_str=$(printf '%s\n' "$input_str" | sed -e "s/&[^[:space:]]*;/$sep_char/g")
  input_str=$(printf '%s\n' "$input_str" | iconv -f utf-8 -t ASCII//TRANSLIT 2> /dev/null) || return
  input_str=${input_str//\?/}
  input_str="${input_str//[\`\'\"’´]}"
  ((preserve_case)) || input_str="${input_str,,}"
  input_str=$(tr -c 'a-zA-Z0-9' "$sep_char" <<< "$input_str")
  while [[ "$input_str" == *"$sep_char"$sep_char* ]]; do
    input_str="${input_str//"$sep_char"$sep_char/$sep_char}"
  done
  input_str="${input_str#"${sep_char}"}"
  input_str="${input_str%"${sep_char}"}"
  if ((max_len)); then
    if (( ${#input_str} > max_len )); then
      input_str="${input_str:0:$max_len}"
      input_str="${input_str%"$sep_char"*}"
    fi
  fi
  echo -n "$input_str"
}
declare -fx post_slug


# Find BASH-CODING-STANDARD.md in standard locations
find_bcs_file() {
  local -- script_dir=$1
  local -- install_share="${script_dir%/bin}/share/yatti/bash-coding-standard"
  local -a search_paths=(
    "$script_dir"                                 # Same directory (development)
    "$install_share"                              # Relative to script (custom PREFIX)
    /usr/local/share/yatti/bash-coding-standard   # YaTTI local install
    /usr/share/yatti/bash-coding-standard         # YaTTI system install
  )
  local -- path
  for path in "${search_paths[@]}"; do
    [[ -f "$path"/data/BASH-CODING-STANDARD.md ]] && { echo "$path"/data/BASH-CODING-STANDARD.md; return 0; }
  done

  return 1
}
declare -fx find_bcs_file

# ============================================================================
# DEPENDENCY PATH RESOLUTION
# ============================================================================

# Find agent script in vendored or development locations
# Priority: lib/agents/ (bundled) → /ai/scripts (development)
find_agent() {
  local -- agent_name=$1
  local -- install_share="${BCS_DIR%/bin}/share/yatti/bash-coding-standard/lib/agents"
  local -a search_paths=(
    "$BCS_DIR/lib/agents/$agent_name"                       # Same directory (development)
    "$install_share/$agent_name"                            # Relative to script (installed)
    /usr/local/share/yatti/bash-coding-standard/lib/agents/"$agent_name"  # YaTTI local install
    /usr/share/yatti/bash-coding-standard/lib/agents/"$agent_name"        # YaTTI system install
    "/ai/scripts/claude/agents/$agent_name"                 # Development fallback
  )

  local -- path
  for path in "${search_paths[@]}"; do
    if [[ -x "$path" ]]; then
      echo "$path"
      return 0
    fi
  done

  return 1
}
declare -fx find_agent

# Find md2ansi in vendored, system PATH, or development locations
# Priority: lib/md2ansi/ (bundled) → system PATH
find_md2ansi() {
  local -- install_share="${BCS_DIR%/bin}/share/yatti/bash-coding-standard/lib/md2ansi"
  local -a search_paths=(
    "$BCS_DIR/lib/md2ansi/md2ansi"                       # Same directory (development)
    "$install_share/md2ansi"                             # Relative to script (installed)
    /usr/local/share/yatti/bash-coding-standard/lib/md2ansi/md2ansi  # YaTTI local install
    /usr/share/yatti/bash-coding-standard/lib/md2ansi/md2ansi        # YaTTI system install
    "$(command -v md2ansi 2>/dev/null || true)"          # System PATH (fallback)
  )

  local -- path
  for path in "${search_paths[@]}"; do
    if [[ -n "$path" && -x "$path" ]]; then
      echo "$path"
      return 0
    fi
  done

  return 1
}
declare -fx find_md2ansi

# ============================================================================

# Find data/ directory in standard locations
find_data_dir() {
  local -- install_share="${BCS_DIR%/bin}/share/yatti/bash-coding-standard/data"
  local -a search_paths=(
    "$BCS_DIR/data"                                   # Same directory (development)
    "$install_share"                                  # Relative to script (custom PREFIX)
    /usr/local/share/yatti/bash-coding-standard/data  # YaTTI local install
    /usr/share/yatti/bash-coding-standard/data        # YaTTI system install
  )
  local -- path
  for path in "${search_paths[@]}"; do
    [[ -d "$path" ]] && { echo "$path"; return 0; }
  done

  return 1
}
declare -fx find_data_dir

# Extract BCS code from rule file path
# BCS rule code format: BCS{catNo}[{ruleNo}][{subruleNo}]
# All numbers are two digits, eg BCS1401, BCS0402, BCS010201
get_bcs_code() {
  local -- filepath=$1
  local -- bcs_ref=''
  local -a heads=()

  [[ -f "$filepath" ]] || return 2

  # Extract all ##- patterns from path
  readarray -t heads < <(grep -so '[0-9][0-9]-' <<<"$filepath")
  ((${#heads[@]})) || return 1

  # Concatenate all numbers and remove dashes
  printf -v bcs_ref '%s' "${heads[@]}"
  echo -n "BCS${bcs_ref//-/}"
  return 0
}
declare -fx get_bcs_code

# Get default tier by reading BASH-CODING-STANDARD.md symlink
# Returns: complete, abstract, or summary
# Falls back to 'abstract' if symlink doesn't exist or can't be read
get_default_tier() {
  # Find BASH-CODING-STANDARD.md using FHS-compliant search
  local -- bcs_file
  bcs_file=$(find_bcs_file "$BCS_DIR") || {
    echo 'abstract'
    return 0
  }

  # Check if it's a symlink
  [[ -L "$bcs_file" ]] || {
    echo 'abstract'
    return 0
  }

  # Read symlink target
  local -- target
  target=$(readlink "$bcs_file") || {
    echo 'abstract'
    return 0
  }

  # Extract tier from filename (e.g., "complete" from "BASH-CODING-STANDARD.complete.md")
  if [[ "$target" =~ \.complete\.md$ ]]; then
    echo 'complete'
  elif [[ "$target" =~ \.summary\.md$ ]]; then
    echo 'summary'
  elif [[ "$target" =~ \.abstract\.md$ ]]; then
    echo 'abstract'
  elif [[ "$target" =~ \.rulet\.md$ ]]; then
    echo 'rulet'
  else
    # Fallback
    echo 'abstract'
  fi

  return 0
}
declare -fx get_default_tier

# Rebuild BCS/ directory structure and create BCS code symlinks
rebuild_bcs_index() {
  local -- data_dir
  data_dir=$(find_data_dir) || { error 'Data directory not found'; return 1; }

  # BCS index directory is parallel to data/ directory
  local -- bcs_index_dir="${data_dir%/data}/BCS"

  # Validate directories exist
  [[ -d "$data_dir" ]] || { error "Data directory not found '$data_dir'"; return 1; }

  info 'Starting BCS directory rebuild'
  >&2 echo

  # Clean BCS directory (preserve .claude directory)
  info "Cleaning BCS directory '$bcs_index_dir'"
  local -a subdirs=()
  readarray -t subdirs < <(find "$bcs_index_dir" -mindepth 1 -maxdepth 1 -type d -not -name '.claude' 2>/dev/null)

  if ((${#subdirs[@]} > 0)); then
    local -- subdir
    for subdir in "${subdirs[@]}"; do
      info "  Removing ${subdir@Q}"
      rm -rf "$subdir"
    done
    success "Removed ${#subdirs[@]} directories"
    >&2 echo
  fi

  # Rebuild directory structure from data/
  info "Rebuilding directory structure from ${data_dir@Q}"

  # Use find with -printf to extract and recreate directory structure
  local -a dirs=()
  readarray -t dirs < <(find "$data_dir" -type d -printf '%P\0' | xargs -0 -n1 echo | grep -v '^$' | grep -v '^templates')

  local -- dir
  for dir in "${dirs[@]}"; do
    mkdir -p "$bcs_index_dir"/"$dir"
  done

  success "Created ${#dirs[@]} director$(y ${#dirs[@]})"
  >&2 echo

  # Create short numeric symlinks for numbered directories at all levels
  # Examples: 01 -> 01-script-structure/, 01-script-structure/02 -> 02-shebang/
  info 'Creating short numeric directory symlinks'
  >&2 echo

  local -i dir_symlink_count=0
  for dir in "${dirs[@]}"; do
    # Extract the basename of the directory
    local -- dir_basename
    dir_basename=$(basename "$dir")

    # Check if basename starts with ##- pattern
    if [[ "$dir_basename" =~ ^([0-9][0-9])- ]]; then
      local -- num="${BASH_REMATCH[1]}"
      local -- parent_dir
      parent_dir=$(dirname "$dir")

      # Determine link location and target
      local -- link_path target_path
      if [[ "$parent_dir" == "." ]]; then
        # Top-level directory: create symlink in BCS root
        link_path="$bcs_index_dir/$num"
        target_path="$dir_basename/"
      else
        # Subdirectory: create symlink in parent directory
        link_path="$bcs_index_dir/$parent_dir/$num"
        target_path="$dir_basename/"
      fi

      # Only create symlink if it doesn't already exist as a real directory
      if [[ ! -e "$link_path" ]]; then
        ln -sf "$target_path" "$link_path"
        dir_symlink_count+=1
      fi
    fi
  done

  ((dir_symlink_count)) && success "Created $dir_symlink_count director$(y "$dir_symlink_count") symlink$(s $dir_symlink_count)"
  >&2 echo

  # Create BCS code symlinks
  info 'Creating BCS code symlinks'
  >&2 echo

  local -a md_files=()
  readarray -t md_files < <(find "$data_dir" -type f -name '[0-9][0-9]-*.md' ! -name 'README.md' ! -path '*/templates/*' | sort)

  local -- file bcs_code link_dir link_name
  local -i symlink_count=0 skipped_count=0

  for file in "${md_files[@]}"; do
    # Determine link directory (same subdirectory structure as file, relative to data/)
    link_dir="$bcs_index_dir/${file#"$data_dir"/}"
    link_dir="${link_dir%/*}"  # Remove filename

    # Extract basename and numeric prefix
    local -- basename
    basename=$(basename "$file")

    # Extract the ##- prefix (e.g., "01-", "02-", "10-")
    local -- numeric_prefix
    if [[ "$basename" =~ ^([0-9][0-9])[-].*\.(complete|summary|abstract)\.md$ ]]; then
      numeric_prefix="${BASH_REMATCH[1]}"
      local -- tier=".${BASH_REMATCH[2]}.md"

      # Create link name: just the number + tier (e.g., "01.complete.md")
      link_name="$link_dir/$numeric_prefix$tier"

      # Create symlink (absolute path)
      ln -sf "$file" "$link_name"
      symlink_count+=1
    else
      warn "Skipping file with unexpected naming '$file'"
      skipped_count+=1
    fi
  done

  success "Created $symlink_count symlink$(s $symlink_count)"
  ((skipped_count)) && warn "Skipped $skipped_count file$(s $skipped_count)"
  >&2 echo
}
declare -fx rebuild_bcs_index

# ============================================================================
# Compression Helper Functions (Developer Mode)
# ============================================================================

# Validate Claude CLI availability and capabilities
compress_validate_claude_cli() {
  local -- claude_cmd="${1:-claude}"

  command -v "$claude_cmd" >/dev/null 2>&1 || {
    error "Claude CLI not found: $claude_cmd"
    info 'Install from: https://claude.ai/code'
    return 1
  }

  # Test Claude with required flags
  if ! "$claude_cmd" --help 2>&1 | grep -q 'dangerously-skip-permissions'; then
    error "Claude CLI does not support --dangerously-skip-permissions flag"
    info 'Update Claude CLI to latest version'
    return 1
  fi

  success "Claude CLI validated: $claude_cmd"
  return 0
}
declare -fx compress_validate_claude_cli

# Sanitize UTF-8 encoding in a file by replacing control characters
sanitize_utf8() {
  local -- file="$1"
  local -- temp_file="${file}.utf8tmp"

  # Replace control characters with UTF-8 symbols, then validate encoding
  # 0x0c (FF)  → remove (form feed)
  # 0x13 (DC3) → ✓ (CHECK MARK)
  # 0x17 (ETB) → ✗ (BALLOT X)
  # 0x14 (DC4) → – (EN DASH)
  # 0x92       → ' (RIGHT SINGLE QUOTATION MARK)

  if sed 's/\x0c//g; s/\x13/✓/g; s/\x17/✗/g; s/\x14/–/g' "$file" | \
     iconv -f WINDOWS-1252 -t UTF-8//TRANSLIT 2>/dev/null > "$temp_file"; then
    # Success with iconv conversion
    :
  else
    # Fallback: just sed replacements without iconv
    sed 's/\x0c//g; s/\x13/✓/g; s/\x17/✗/g; s/\x14/–/g; s/\x92/'\''/g' "$file" > "$temp_file"
  fi

  if [[ -s "$temp_file" ]]; then
    mv "$temp_file" "$file"
    return 0
  else
    rm -f "$temp_file"
    return 1
  fi
}
declare -fx sanitize_utf8

# Build system prompt for summary tier compression
compress_build_system_prompt_summary() {
  cat <<'PROMPT'
You are a technical documentation compressor specializing in Bash Coding Standard rules.

TASK: The user will provide a source .complete.md file path and an output file path in their prompt. Use the Read tool to read the source file, compress it to .summary.md format, then use the Write tool to write the compressed result to the output file path.

TARGET SIZE: Maximum 10,000 bytes (strict limit)

CRITICAL REQUIREMENTS (NON-NEGOTIABLE):
1. NEVER alter, simplify, or change code examples - preserve EXACT syntax
2. NEVER lose unique technical details - accuracy is paramount
3. Consolidate rationale points - merge duplicates, eliminate redundancy, keep unique technical insights only
4. Keep 3-5 most critical anti-patterns with examples (deduplicate overlapping ones)
5. Keep 2-3 most important edge cases (merge similar cases)
6. Preserve all code blocks completely (but remove redundant examples showing same pattern)
7. Maintain technical precision in all statements

DEDUPLICATION REQUIREMENTS:
- Identify and merge duplicate explanations of the same concept
- If a concept is explained multiple times, consolidate into single clearest statement
- Remove redundant examples that demonstrate the same principle
- Merge overlapping anti-patterns into comprehensive single examples
- One clear statement of each concept beats three redundant variations

COMPRESSION APPROACH:
- Reorganize content to group related concepts and eliminate duplication
- Reword verbose statements for brevity while preserving technical precision
- Remove verbose explanations while keeping technical facts
- Consolidate similar examples - if pattern X appears in 3 examples, show best one
- Keep measurable/specific details (performance numbers, specific errors)
- Remove obvious elaborations and redundant explanations
- Maintain structure: title, rationale, examples, anti-patterns, edge cases

CRITICAL FILE WRITING:
- Use the Write tool to write ONLY the compressed markdown content to the output file
- NO meta-commentary about the compression process in the file
- NO "Summary" sections explaining what you did in the file
- NO lists of "Key achievements" or "Compression techniques used" in the file
- The file content will be directly concatenated into the final document
- Think of the file content as the final published content, not a report about compression
- The file should start immediately with the rule title/content (markdown format)

OUTPUT: Use Write tool to create valid markdown file following .summary.md structure, under 10,000 bytes.
PROMPT
}
declare -fx compress_build_system_prompt_summary

# Build system prompt for abstract tier compression
compress_build_system_prompt_abstract() {
  local -- bcs_code="$1"
  cat <<PROMPT
You are a technical documentation compressor specializing in Bash Coding Standard rules.

TASK: The user will provide a source .complete.md file path and an output file path in their prompt. Use the Read tool to read the source file, compress it to .abstract.md format (ultra-concise), then use the Write tool to write the compressed result to the output file path.

TARGET SIZE: Maximum 1,500 bytes (ultra-compressed, strict limit)

CRITICAL REQUIREMENTS (NON-NEGOTIABLE):
1. NEVER alter code examples - preserve EXACT syntax (but use minimal examples)
2. Keep only THE MOST critical technical details
3. Top 2-3 rationale points (most measurable/technical)
4. One minimal but ACCURATE code example (5-8 lines max)
5. 1-2 most critical anti-patterns only
6. Add reference line as LAST LINE: "**Ref:** $bcs_code" (file must end with single newline, no extra blank lines)
7. Extreme brevity - every word must add unique value

COMPRESSION APPROACH:
- One-sentence rule statement in bold
- Inline anti-patterns using \`→\` notation where possible
- Remove all elaboration - state fact, move on
- Keep only information that changes behavior or prevents catastrophic errors
- Use minimal examples showing core pattern only

CRITICAL FILE WRITING:
- Use the Write tool to write ONLY the compressed markdown content to the output file
- NO meta-commentary about the compression process in the file
- NO "Summary" sections explaining what you did in the file
- NO lists of "Key achievements" or "Compression techniques used" in the file
- The file content will be directly concatenated into the final document
- Think of the file content as the final published content, not a report about compression
- The file should start immediately with the rule title/content (markdown format)
- File MUST end with "**Ref:** BCS####" line followed by exactly one newline character

OUTPUT: Use Write tool to create ultra-concise markdown file following .abstract.md structure, under 1,500 bytes.
PROMPT
}
declare -fx compress_build_system_prompt_abstract

# Build strict system prompt for abstract tier compression (retry)
compress_build_system_prompt_abstract_strict() {
  local -i current_size=$1
  local -- bcs_code="$2"
  cat <<PROMPT
You are a technical documentation compressor specializing in Bash Coding Standard rules.

TASK: The user will provide a source .complete.md file path and an output file path in their prompt. Use the Read tool to read the source file, compress it to .abstract.md format (ultra-concise), then use the Write tool to write the compressed result to the output file path.

TARGET SIZE: Maximum 1,500 bytes (STRICT - previous attempt was $current_size bytes)

CRITICAL REQUIREMENTS (NON-NEGOTIABLE):
1. NEVER alter code examples - preserve EXACT syntax
2. RUTHLESSLY remove all non-essential text
3. ONE rationale point only (most critical)
4. ONE minimal code example (3-5 lines max)
5. ONE anti-pattern maximum
6. Add reference line as LAST LINE: "**Ref:** $bcs_code" (file must end with single newline, no extra blank lines)
7. Ultra-extreme brevity - remove all elaboration

COMPRESSION APPROACH:
- Single sentence rule in bold
- Inline examples using backticks where possible instead of code blocks
- Remove all explanatory text
- Keep ONLY information that prevents critical errors
- Abbreviate aggressively

CRITICAL FILE WRITING:
- Use the Write tool to write ONLY the compressed markdown content to the output file
- NO meta-commentary about the compression process in the file
- NO "Summary" sections explaining what you did in the file
- NO lists of "Key achievements" or "Compression techniques used" in the file
- The file content will be directly concatenated into the final document
- Think of the file content as the final published content, not a report about compression
- The file should start immediately with the rule title/content (markdown format)
- File MUST end with "**Ref:** BCS####" line followed by exactly one newline character

OUTPUT: Use Write tool to create ultra-minimal markdown file, MUST be under 1,500 bytes.
PROMPT
}
declare -fx compress_build_system_prompt_abstract_strict

# Build strict system prompt for summary tier compression (retry)
compress_build_system_prompt_summary_strict() {
  local -i current_size=$1
  cat <<PROMPT
You are a technical documentation compressor specializing in Bash Coding Standard rules.

TASK: The user will provide a source .complete.md file path and an output file path in their prompt. Use the Read tool to read the source file, compress it to .summary.md format (balanced version), then use the Write tool to write the compressed result to the output file path.

TARGET SIZE: Maximum 10,000 bytes (STRICT - previous attempt was $current_size bytes)

CRITICAL REQUIREMENTS (NON-NEGOTIABLE):
1. NEVER alter code examples - preserve EXACT syntax
2. Aggressively merge and deduplicate rationale - eliminate ALL redundancy, keep 2-3 unique key points only
3. Keep 2-3 most critical anti-patterns only (merge overlapping ones ruthlessly)
4. Keep 1-2 most important edge cases (merge similar cases)
5. Preserve code blocks but remove ALL verbose explanations and redundant examples
6. Remove all redundant elaboration - every sentence must add unique value

DEDUPLICATION (AGGRESSIVE):
- Ruthlessly identify duplicate concepts and merge them into single statements
- Reorganize to eliminate ALL redundant explanations
- One clear statement of each concept - absolutely no repetition
- If same pattern shown in multiple examples, keep only the clearest one
- Merge overlapping rationale points into comprehensive single points

COMPRESSION APPROACH:
- Remove ALL verbose explanations and elaboration
- Consolidate similar examples ruthlessly (keep syntax exact)
- Cut non-essential edge cases and redundant demonstrations
- Remove obvious statements and redundant descriptions
- Reorganize content to group related concepts tightly
- Reword for maximum brevity while maintaining precision
- Keep structure but minimize all prose to bare essentials

CRITICAL FILE WRITING:
- Use the Write tool to write ONLY the compressed markdown content to the output file
- NO meta-commentary about the compression process in the file
- NO "Summary" sections explaining what you did in the file
- NO lists of "Key achievements" or "Compression techniques used" in the file
- The file content will be directly concatenated into the final document
- Think of the file content as the final published content, not a report about compression
- The file should start immediately with the rule title/content (markdown format)

OUTPUT: Use Write tool to create concise markdown file following .summary.md structure, MUST be under 10,000 bytes.
PROMPT
}
declare -fx compress_build_system_prompt_summary_strict

# Check if all three tier files have matching timestamps
compress_check_timestamps_match() {
  local -- complete_file=$1
  local -- summary_file=$2
  local -- abstract_file=$3

  # All three files must exist
  [[ -f "$complete_file" && -f "$summary_file" && -f "$abstract_file" ]] || return 1

  # Get modification times
  local -- complete_mtime summary_mtime abstract_mtime
  complete_mtime=$(stat -c '%Y' "$complete_file" 2>/dev/null) || return 1
  summary_mtime=$(stat -c '%Y' "$summary_file" 2>/dev/null) || return 1
  abstract_mtime=$(stat -c '%Y' "$abstract_file" 2>/dev/null) || return 1

  # Check if all three timestamps match
  [[ "$complete_mtime" == "$summary_mtime" && "$summary_mtime" == "$abstract_mtime" ]]
}
declare -fx compress_check_timestamps_match

# Compress a single rule from .complete.md to specified tier
compress_rule_to_tier() {
  local -- complete_file="$1"
  local -- tier="$2"
  local -- claude_cmd="$3"
  local -i dry_run="${4:-0}"
  local -i compress_verbose="${5:-1}"
  local -i target_size="${6:-1500}"  # Default for abstract
  local -- context_level="${7:-none}"  # Context level: none, toc, abstract, summary, complete
  local -i max_retries=3

  # Extract base name: /path/01-layout.complete.md → 01-layout
  local -- basename=${complete_file##*/}
  basename=${basename%.complete.md}

  # Generate target filename
  local -- target_dir=${complete_file%/*}
  local -- target_file="$target_dir/$basename.$tier.md"

  # Calculate BCS code for this file
  local -- bcs_code
  bcs_code=$(get_bcs_code "$complete_file") || bcs_code='BCS????'

  ((compress_verbose)) && vecho "  → Generating .$tier.md (BCS: $bcs_code)..."

  # Delete existing file if in regenerate mode (already handled by caller)

  if ((dry_run)); then
    ((compress_verbose)) && info "  [DRY-RUN] Would generate: $target_file"
    return 0
  fi

  # Build context file based on context_level (once, before retry loop)
  # Use temp file to avoid command substitution null byte issues with form feed chars
  local -- context_file_persistent=""
  case "$context_level" in
    abstract)
      ((compress_verbose)) && vecho "    Using abstract context (excluding $bcs_code)"
      context_file_persistent=$(mktemp) || {
        ((compress_verbose)) && warn "    Failed to create context temp file"
        context_file_persistent=""
      }
      if [[ -n "$context_file_persistent" ]]; then
        if ! build_context_abstract_exclude "$bcs_code" "$context_file_persistent"; then
          ((compress_verbose)) && warn "    Failed to build abstract context with exclusion, falling back to full context"
          if ! build_context_abstract > "$context_file_persistent"; then
            ((compress_verbose)) && warn "    Failed to build abstract context, continuing without it"
            rm -f "$context_file_persistent"
            context_file_persistent=""
          fi
        fi
      fi
      ;;
    summary)
      ((compress_verbose)) && vecho "    Using summary context (excluding $bcs_code)"
      context_file_persistent=$(mktemp) || {
        ((compress_verbose)) && warn "    Failed to create context temp file"
        context_file_persistent=""
      }
      if [[ -n "$context_file_persistent" ]]; then
        if ! build_context_summary_exclude "$bcs_code" "$context_file_persistent"; then
          ((compress_verbose)) && warn "    Failed to build summary context with exclusion, falling back to full context"
          if ! build_context_summary > "$context_file_persistent"; then
            ((compress_verbose)) && warn "    Failed to build summary context, continuing without it"
            rm -f "$context_file_persistent"
            context_file_persistent=""
          fi
        fi
      fi
      ;;
    complete)
      ((compress_verbose)) && vecho "    Using complete context (excluding $bcs_code)"
      context_file_persistent=$(mktemp) || {
        ((compress_verbose)) && warn "    Failed to create context temp file"
        context_file_persistent=""
      }
      if [[ -n "$context_file_persistent" ]]; then
        if ! build_context_complete_exclude "$bcs_code" "$context_file_persistent"; then
          ((compress_verbose)) && warn "    Failed to build complete context with exclusion, falling back to full context"
          if ! build_context_complete > "$context_file_persistent"; then
            ((compress_verbose)) && warn "    Failed to build complete context, continuing without it"
            rm -f "$context_file_persistent"
            context_file_persistent=""
          fi
        fi
      fi
      ;;
    toc)
      ((compress_verbose)) && vecho "    Using TOC context for structure awareness"
      context_file_persistent=$(mktemp) || {
        ((compress_verbose)) && warn "    Failed to create context temp file"
        context_file_persistent=""
      }
      if [[ -n "$context_file_persistent" ]]; then
        if ! build_context_toc > "$context_file_persistent"; then
          ((compress_verbose)) && warn "    Failed to build TOC context, continuing without it"
          rm -f "$context_file_persistent"
          context_file_persistent=""
        fi
      fi
      ;;
    none|"")
      context_file_persistent=""
      ;;
    *)
      ((compress_verbose)) && warn "    Unknown context level '$context_level', using none"
      context_file_persistent=""
      ;;
  esac

  # Retry loop for oversized files
  local -i attempt=1
  local -i file_size=0
  local -- temp_file system_prompt

  while ((attempt <= max_retries)); do
    # Build system prompt based on tier and attempt
    if ((attempt == 1)); then
      # First attempt - standard prompt
      if [[ "$tier" == 'summary' ]]; then
        system_prompt=$(compress_build_system_prompt_summary)
      else
        system_prompt=$(compress_build_system_prompt_abstract "$bcs_code")
      fi
    else
      # Retry with stricter prompt
      if [[ "$tier" == 'summary' ]]; then
        system_prompt=$(compress_build_system_prompt_summary_strict "$file_size")
      else
        system_prompt=$(compress_build_system_prompt_abstract_strict "$file_size" "$bcs_code")
      fi
      ((compress_verbose)) && warn "  ↻ Retry attempt $attempt with stricter compression..."
    fi

    # Create temporary file for atomic write
    temp_file=$(mktemp) || { error 'Failed to create temporary file'; return 1; }

    # Invoke Claude with file paths as prompt (Read/Write tools enabled)
    # Context is already in context_file_persistent if needed
    local -i claude_exit=0

    # Skip tee if stderr is not a terminal (non-interactive or piped)
    local use_tee=0
    [[ -t 2 ]] && use_tee=1

    if [[ -n "$context_file_persistent" ]]; then
      # Tell Claude to read context file first, then process the target file
      if ((use_tee)); then
        "$claude_cmd" --print --dangerously-skip-permissions \
           --allowedTools "Read" "Write" \
           --system-prompt "$system_prompt" \
           "Read context: $context_file_persistent | Read source: $complete_file | Write compressed to: $temp_file" \
           2>&1 | tee /dev/stderr || claude_exit=$?
      else
        "$claude_cmd" --print --dangerously-skip-permissions \
           --allowedTools "Read" "Write" \
           --system-prompt "$system_prompt" \
           "Read context: $context_file_persistent | Read source: $complete_file | Write compressed to: $temp_file" \
           2>&1 || claude_exit=$?
      fi
    else
      if ((use_tee)); then
        "$claude_cmd" --print --dangerously-skip-permissions \
           --allowedTools "Read" "Write" \
           --system-prompt "$system_prompt" \
           "Read file: $complete_file | Write compressed output to: $temp_file" \
           2>&1 | tee /dev/stderr || claude_exit=$?
      else
        "$claude_cmd" --print --dangerously-skip-permissions \
           --allowedTools "Read" "Write" \
           --system-prompt "$system_prompt" \
           "Read file: $complete_file | Write compressed output to: $temp_file" \
           2>&1 || claude_exit=$?
      fi
    fi

    # Check if Claude invocation succeeded
    if ((claude_exit == 0)); then
      # Check if temp file was actually written to (size > 0)
      if [[ ! -s "$temp_file" ]]; then
        ((compress_verbose)) && warn "  ⚠ Claude succeeded but wrote empty file (possible API error)"
        rm -f "$temp_file"
        sleep $((2 ** attempt))  # Exponential backoff: 2, 4, 8 seconds
        attempt+=1
        continue
      fi

      # Sanitize UTF-8 encoding in Claude's output
      sanitize_utf8 "$temp_file" || ((compress_verbose)) && warn "  ⚠ UTF-8 sanitization failed"

      # Check file size
      file_size=$(wc -c < "$temp_file")

      # Check if size is acceptable
      if ((file_size <= target_size)); then
        # Success - move temp file to target
        mv "$temp_file" "$target_file" || { error "Failed to write: $target_file"; return 1; }

        # Copy permissions, ownership, and timestamp from source .complete.md file
        # Use explicit values as fallback if --reference fails
        if ! chmod --reference="$complete_file" "$target_file" 2>/dev/null; then
          # Fallback: get permissions explicitly and apply them
          local -- perms
          perms=$(stat -c '%a' "$complete_file" 2>/dev/null) && chmod "$perms" "$target_file" 2>/dev/null || {
            # Final fallback: use safe default 644
            chmod 664 "$target_file" 2>/dev/null || true
          }
        fi

        # Try to copy ownership (may fail without root, that's OK)
        chown --reference="$complete_file" "$target_file" 2>/dev/null || true

        # Sync timestamp - use explicit method as fallback
        if ! touch -r "$complete_file" "$target_file" 2>/dev/null; then
          # Fallback: get timestamp explicitly and apply it
          local -- timestamp
          timestamp=$(stat -c '%Y' "$complete_file" 2>/dev/null) && touch -d "@$timestamp" "$target_file" 2>/dev/null || {
            ((compress_verbose)) && warn "  Failed to sync timestamp for: $target_file"
          }
        fi

        ((compress_verbose)) && success "  ✓ Generated ($file_size bytes): $target_file"
        [[ -n "$context_file_persistent" ]] && rm -f "$context_file_persistent"
        return 0  # Success
      else
        # Oversized - retry or give up
        if ((attempt < max_retries)); then
          ((compress_verbose)) && warn "  ⚠ OVERSIZED ($file_size bytes > $target_size) - retrying..."
          rm -f "$temp_file"
          attempt+=1
        else
          # Max retries reached - keep the oversized file
          mv "$temp_file" "$target_file" || { error "Failed to write: $target_file"; return 1; }

          # Sanitize UTF-8 encoding in oversized file
          sanitize_utf8 "$target_file" || ((compress_verbose)) && warn "  ⚠ UTF-8 sanitization failed"

          # Copy permissions with fallback
          if ! chmod --reference="$complete_file" "$target_file" 2>/dev/null; then
            local -- perms
            perms=$(stat -c '%a' "$complete_file" 2>/dev/null) && chmod "$perms" "$target_file" 2>/dev/null || {
              chmod 664 "$target_file" 2>/dev/null || true
            }
          fi

          # Try to copy ownership
          chown --reference="$complete_file" "$target_file" 2>/dev/null || true

          # Sync timestamp with fallback
          if ! touch -r "$complete_file" "$target_file" 2>/dev/null; then
            local -- timestamp
            timestamp=$(stat -c '%Y' "$complete_file" 2>/dev/null) && touch -d "@$timestamp" "$target_file" 2>/dev/null || {
              ((compress_verbose)) && warn "  Failed to sync timestamp for: $target_file"
            }
          fi

          ((compress_verbose)) && warn "  ⚠ OVERSIZED ($file_size bytes > $target_size): $target_file"
          [[ -n "$context_file_persistent" ]] && rm -f "$context_file_persistent"
          return 2  # Oversized
        fi
      fi
    else
      # Claude invocation failed - check if it's a connection error (retry) or other error
      [[ -f "$temp_file" ]] && rm -f "$temp_file"

      # Check if it's an API connection error (transient, should retry)
      if ((claude_exit == 1)); then
        if ((attempt < max_retries)); then
          ((compress_verbose)) && warn "  ↻ API connection error, retrying in $((2 ** attempt)) seconds (attempt $attempt/$max_retries)..."
          sleep $((2 ** attempt))  # Exponential backoff: 2, 4, 8 seconds
          attempt+=1
          continue
        fi
      fi

      # Not a retryable error or out of retries
      error "  ✗ FAILED: Claude invocation failed for $target_file (exit code: $claude_exit)"
      [[ -n "$context_file_persistent" ]] && rm -f "$context_file_persistent"
      return 1  # Failed
    fi
  done

  # Should not reach here (all retries exhausted)
  [[ -n "$context_file_persistent" ]] && rm -f "$context_file_persistent"
  return 1
}
declare -fx compress_rule_to_tier

# Process a single .complete.md file
compress_process_complete_file() {
  local -- complete_file="$1"
  local -- data_dir="$2"
  local -- tier="$3"
  local -- claude_cmd="$4"
  local -i dry_run="${5:-0}"
  local -i compress_verbose="${6:-1}"
  local -i regenerate="${7:-0}"
  local -i summary_limit="${8:-10000}"
  local -i abstract_limit="${9:-1500}"
  local -- context_level="${10:-none}"  # Context level parameter

  local -- relative_path=${complete_file#"$data_dir/"}

  # Extract base name for derived files
  local -- basename=${complete_file##*/}
  basename=${basename%.complete.md}
  local -- target_dir=${complete_file%/*}
  local -- summary_file="$target_dir/$basename.summary.md"
  local -- abstract_file="$target_dir/$basename.abstract.md"

  # Check if all three files have matching timestamps (indicating they're in sync)
  if ((regenerate)) && compress_check_timestamps_match "$complete_file" "$summary_file" "$abstract_file"; then
    ((compress_verbose)) && vecho "⊙ SKIP (timestamps match): $relative_path"
    return 0
  fi

  ((compress_verbose)) && info "Processing: $relative_path"

  # Process summary tier
  if [[ -z "$tier" || "$tier" == 'summary' ]]; then
    compress_rule_to_tier "$complete_file" 'summary' "$claude_cmd" "$dry_run" "$compress_verbose" "$summary_limit" "$context_level"
  fi

  # Process abstract tier
  if [[ -z "$tier" || "$tier" == 'abstract' ]]; then
    compress_rule_to_tier "$complete_file" 'abstract' "$claude_cmd" "$dry_run" "$compress_verbose" "$abstract_limit" "$context_level"
  fi
}
declare -fx compress_process_complete_file

# Process all .complete.md files in data directory
compress_process_all_rules() {
  local -- data_dir="$1"
  local -- tier="$2"
  local -- claude_cmd="$3"
  local -i dry_run="${4:-0}"
  local -i compress_verbose="${5:-1}"
  local -i summary_limit="${6:-10000}"
  local -i abstract_limit="${7:-1500}"
  local -- context_level="${8:-none}"  # Context level parameter
  local -i force="${9:-0}"  # Force regeneration parameter
  local -i regenerate=1  # Always regenerate when called

  # Find all complete files
  local -a complete_files=()
  readarray -t complete_files < <(find "$data_dir" -type f -name '[0-9][0-9]-*.complete.md' | sort)

  local -i file_count=${#complete_files[@]}

  if ((file_count == 0)); then
    ((compress_verbose)) && warn 'No .complete.md files found'
    return 0
  fi

  ((compress_verbose)) && info "Found $file_count .complete.md files"

  # If force flag is set, touch all .complete.md files to trigger regeneration
  if ((force)); then
    ((compress_verbose)) && info 'Force mode: touching all .complete.md files to bypass timestamp checks'
    if ((dry_run)); then
      ((compress_verbose)) && info '[DRY-RUN] Would touch all .complete.md files'
    else
      local -- file newtime
      for file in "${complete_files[@]}"; do
        newtime=$(awk -v t="$(date +%s.%N -r "$file")" 'BEGIN {printf "%.9f", t + 0.001}')
        touch -d "@$newtime" "$file" || warn "Failed to touch ${file@Q}"
      done
    fi
  fi

  ((compress_verbose)) && >&2 echo

  # Process each file
  local -- file
  for file in "${complete_files[@]}"; do
    compress_process_complete_file "$file" "$data_dir" "$tier" "$claude_cmd" \
      "$dry_run" "$compress_verbose" "$regenerate" "$summary_limit" "$abstract_limit" "$context_level"
  done
}
declare -fx compress_process_all_rules

# Show compression statistics (placeholder - actual stats tracked in cmd_compress)
compress_show_statistics() {
  local -i total_processed="${1:-0}"
  local -i summary_success="${2:-0}"
  local -i summary_oversized="${3:-0}"
  local -i summary_failed="${4:-0}"
  local -i abstract_success="${5:-0}"
  local -i abstract_oversized="${6:-0}"
  local -i abstract_failed="${7:-0}"

  cat <<EOF

${BOLD}Compression Statistics${NC}
$(printf '=%.0s' {1..50})

Files processed: $total_processed complete → compressed

Summary files (.summary.md):
  ${GREEN}✓${NC} Within limit: $summary_success
  ${YELLOW}⚠${NC} Oversized:    $summary_oversized
  ${RED}✗${NC} Failed:       $summary_failed

Abstract files (.abstract.md):
  ${GREEN}✓${NC} Within limit: $abstract_success
  ${YELLOW}⚠${NC} Oversized:    $abstract_oversized
  ${RED}✗${NC} Failed:       $abstract_failed

EOF

  if ((summary_oversized + abstract_oversized > 0)); then
    warn 'Some files exceeded size limits - manual compression recommended'
  fi

  if ((summary_failed + abstract_failed > 0)); then
    error 'Some files failed to generate - check Claude CLI configuration'
  fi
}
declare -fx compress_show_statistics

# Report oversized files in data directory
compress_report_oversized_files() {
  local -- data_dir="$1"
  local -i complete_limit="${2:-20000}"
  local -i summary_limit="${3:-10000}"
  local -i abstract_limit="${4:-1500}"

  # Create associative array with limits
  local -A data_size_limit=(
    [complete]=$complete_limit
    [summary]=$summary_limit
    [abstract]=$abstract_limit
  )

  cd "$data_dir" || { error "Cannot access data directory: $data_dir"; return 2; }

  local -- type
  for type in complete summary abstract; do
    local -a files=()
    readarray -t files < <(find "$data_dir" -type f -name "*.${type}.md")
    echo "$type: ${#files[@]}"
    echo "Over ${data_size_limit[$type]} bytes:"
    find "$data_dir" -type f -name "*.${type}.md" -exec du -b {} + | \
      awk -v limit="${data_size_limit[$type]}" '$1 > limit {printf "    %6d bytes  %s\n", $1, $2}' | \
      sort -rn | \
      sed "s:$data_dir/::"
    echo '---'
  done

  echo
  echo "$BCS_NAME: Target: Reduce all files to ~600-1200 bytes for total ~75KB"
  echo "$BCS_NAME: Strategy: Keep 1 example, 1 anti-pattern, brief principle, ref line"
}
declare -fx compress_report_oversized_files

# Build context prompt with full abstract standard
build_context_abstract() {
  local -- data_dir
  data_dir=$(find_data_dir) || return 1
  local -- abstract_file="$data_dir/BASH-CODING-STANDARD.abstract.md"

  # Check if abstract file exists
  if [[ ! -f "$abstract_file" ]]; then
    warn "Abstract standard not found: $abstract_file"
    return 1
  fi

  cat <<'CONTEXT'
=== CONTEXT: Full BCS Abstract Standard for Cross-Reference ===

Below is the complete BASH-CODING-STANDARD in abstract form. Use this to:

1. **Identify concepts already explained in other rules** - avoid duplicating explanations
2. **Maintain consistent terminology** across all rules (use same terms for same concepts)
3. **Reference related rules** where appropriate (e.g., "see BCS0205 for readonly pattern")
4. **Understand overall structure** - see how your rule fits into the bigger picture
5. **Deduplicate aggressively** - if concept X is explained in BCS01, don't re-explain in BCS08

CRITICAL: Use this context to eliminate cross-rule duplication. If a concept is already
clearly explained in another rule, reference it instead of repeating the explanation.

================================================================================

CONTEXT
  cat "$abstract_file"
  cat <<'END_CONTEXT'

================================================================================

=== END CONTEXT ===

Now compress the target rule file with full awareness of the above context.
END_CONTEXT
}
declare -fx build_context_abstract

# Build context prompt with table of contents only
build_context_toc() {
  local -- data_dir
  data_dir=$(find_data_dir) || return 1

  cat <<'TOC_HEADER'
=== CONTEXT: BCS Structure Overview ===

The Bash Coding Standard consists of 14 sections. Use this overview to:
1. Understand where concepts are covered
2. Avoid duplicating content from other sections
3. Reference related sections appropriately

Section Overview:

TOC_HEADER

  # Generate TOC from directory structure
  local -a section_dirs=()
  readarray -t section_dirs < <(find "$data_dir" -maxdepth 1 -type d -name '[0-9][0-9]-*' | sort)

  local -- dir section_num section_name
  for dir in "${section_dirs[@]}"; do
    section_num=$(basename "$dir" | grep -o '^[0-9][0-9]')
    section_name=$(basename "$dir" | sed 's/^[0-9][0-9]-//' | tr '-' ' ' | sed 's/\b\(.\)/\u\1/g')

    # Read first few lines of section file to get description
    local -- section_file="$dir"/00-section.abstract.md
    if [[ -f "$section_file" ]]; then
      local -- description
      description=$(head -n 5 "$section_file" | grep -v '^#\|^$' | head -n 1 | sed 's/^\*\*//;s/\*\*$//')
      printf '%s. %s - %s\n' "$section_num" "$section_name" "$description"
    else
      printf '%s. %s\n' "$section_num" "$section_name"
    fi
  done

  cat <<'TOC_FOOTER'

Use this structure to avoid duplicating content between sections.
If a concept is primarily covered in another section, reference it instead of repeating.

=== END CONTEXT ===
TOC_FOOTER
}
declare -fx build_context_toc

# Build context prompt with full summary standard
build_context_summary() {
  local -- data_dir
  data_dir=$(find_data_dir) || return 1
  local -- summary_file="$data_dir/BASH-CODING-STANDARD.summary.md"

  # Check if summary file exists
  if [[ ! -f "$summary_file" ]]; then
    warn "Summary standard not found: $summary_file"
    return 1
  fi

  cat <<'CONTEXT'
=== CONTEXT: Full BCS Summary Standard for Cross-Reference ===

Below is the complete BASH-CODING-STANDARD in summary form. Use this to:

1. **Identify concepts already explained in other rules** - avoid duplicating explanations
2. **Maintain consistent terminology** across all rules (use same terms for same concepts)
3. **Reference related rules** where appropriate (e.g., "see BCS0205 for readonly pattern")
4. **Understand overall structure** - see how your rule fits into the bigger picture
5. **Deduplicate aggressively** - if concept X is explained in BCS01, don't re-explain in BCS08

CRITICAL: Use this context to eliminate cross-rule duplication. If a concept is already
clearly explained in another rule, reference it instead of repeating the explanation.

================================================================================

CONTEXT
  cat "$summary_file"
  cat <<'END_CONTEXT'

================================================================================

=== END CONTEXT ===

Now compress the target rule file with full awareness of the above context.
END_CONTEXT
}
declare -fx build_context_summary

# Build context prompt with full complete standard
build_context_complete() {
  local -- data_dir
  data_dir=$(find_data_dir) || return 1
  local -- complete_file="$data_dir/BASH-CODING-STANDARD.complete.md"

  # Check if complete file exists
  if [[ ! -f "$complete_file" ]]; then
    warn "Complete standard not found: $complete_file"
    return 1
  fi

  cat <<'CONTEXT'
=== CONTEXT: Full BCS Complete Standard for Cross-Reference ===

Below is the complete BASH-CODING-STANDARD in its full form. Use this to:

1. **Identify concepts already explained in other rules** - avoid duplicating explanations
2. **Maintain consistent terminology** across all rules (use same terms for same concepts)
3. **Reference related rules** where appropriate (e.g., "see BCS0205 for readonly pattern")
4. **Understand overall structure** - see how your rule fits into the bigger picture
5. **Deduplicate aggressively** - if concept X is explained in BCS01, don't re-explain in BCS08

CRITICAL: Use this context to eliminate cross-rule duplication. If a concept is already
clearly explained in another rule, reference it instead of repeating the explanation.

================================================================================

CONTEXT
  cat "$complete_file"
  cat <<'END_CONTEXT'

================================================================================

=== END CONTEXT ===

Now compress the target rule file with full awareness of the above context.
END_CONTEXT
}
declare -fx build_context_complete

# Build context prompt with summary standard, excluding specified BCS code
# Args: bcs_code to exclude, output_file
# Returns: 0 on success, 1 on failure
# Note: Caller is responsible for cleaning up the output file
build_context_summary_exclude() {
  local -- exclude_code="${1:?'build_context_summary_exclude: BCS code required'}"
  local -- output_file="${2:?'build_context_summary_exclude: output file required'}"

  # Generate temporary file with excluded rule
  local -- temp_data
  temp_data=$(mktemp) || {
    warn "Failed to create temp file for context generation"
    return 1
  }

  # Generate summary standard excluding the current rule
  if ! cmd_generate -t summary -x "$exclude_code" -o "$temp_data" 2>/dev/null; then
    warn "Failed to generate summary context excluding $exclude_code"
    rm -f "$temp_data"
    return 1
  fi

  # Build context file with header, data, and footer
  {
    cat <<'CONTEXT'
=== CONTEXT: Full BCS Summary Standard for Cross-Reference ===

Below is the complete BASH-CODING-STANDARD in summary form (EXCLUDING the current rule being compressed). Use this to:

1. **Identify concepts already explained in other rules** - avoid duplicating explanations
2. **Maintain consistent terminology** across all rules (use same terms for same concepts)
3. **Reference related rules** where appropriate (e.g., "see BCS0205 for readonly pattern")
4. **Understand overall structure** - see how your rule fits into the bigger picture
5. **Deduplicate aggressively** - if concept X is explained in BCS01, don't re-explain in BCS08

CRITICAL: Use this context to eliminate cross-rule duplication. If a concept is already
clearly explained in another rule, reference it instead of repeating the explanation.

================================================================================

CONTEXT
    cat "$temp_data"
    cat <<'END_CONTEXT'

================================================================================

=== END CONTEXT ===

Now compress the target rule file with full awareness of the above context.
END_CONTEXT
  } > "$output_file"

  # Cleanup temp data file
  rm -f "$temp_data"
  return 0
}
declare -fx build_context_summary_exclude

# Build context prompt with abstract standard, excluding specified BCS code
# Args: bcs_code to exclude, output_file
# Returns: 0 on success, 1 on failure
# Note: Caller is responsible for cleaning up the output file
build_context_abstract_exclude() {
  local -- exclude_code="${1:?'build_context_abstract_exclude: BCS code required'}"
  local -- output_file="${2:?'build_context_abstract_exclude: output file required'}"

  # Generate temporary file with excluded rule
  local -- temp_data
  temp_data=$(mktemp) || {
    warn "Failed to create temp file for context generation"
    return 1
  }

  # Generate abstract standard excluding the current rule
  if ! cmd_generate -t abstract -x "$exclude_code" -o "$temp_data" 2>/dev/null; then
    warn "Failed to generate abstract context excluding $exclude_code"
    rm -f "$temp_data"
    return 1
  fi

  # Build context file with header, data, and footer
  {
    cat <<'CONTEXT'
=== CONTEXT: Full BCS Abstract Standard for Cross-Reference ===

Below is the complete BASH-CODING-STANDARD in abstract form (EXCLUDING the current rule being compressed). Use this to:

1. **Identify concepts already explained in other rules** - avoid duplicating explanations
2. **Maintain consistent terminology** across all rules (use same terms for same concepts)
3. **Reference related rules** where appropriate (e.g., "see BCS0205 for readonly pattern")
4. **Understand overall structure** - see how your rule fits into the bigger picture
5. **Deduplicate aggressively** - if concept X is explained in BCS01, don't re-explain in BCS08

CRITICAL: Use this context to eliminate cross-rule duplication. If a concept is already
clearly explained in another rule, reference it instead of repeating the explanation.

================================================================================

CONTEXT
    cat "$temp_data"
    cat <<'END_CONTEXT'

================================================================================

=== END CONTEXT ===

Now compress the target rule file with full awareness of the above context.
END_CONTEXT
  } > "$output_file"

  # Cleanup temp data file
  rm -f "$temp_data"
  return 0
}
declare -fx build_context_abstract_exclude

# Build context prompt with complete standard, excluding specified BCS code
# Args: bcs_code to exclude, output_file
# Returns: 0 on success, 1 on failure
# Note: Caller is responsible for cleaning up the output file
build_context_complete_exclude() {
  local -- exclude_code="${1:?'build_context_complete_exclude: BCS code required'}"
  local -- output_file="${2:?'build_context_complete_exclude: output file required'}"

  # Generate temporary file with excluded rule
  local -- temp_data
  temp_data=$(mktemp) || {
    warn "Failed to create temp file for context generation"
    return 1
  }

  # Generate complete standard excluding the current rule
  if ! cmd_generate -t complete -x "$exclude_code" -o "$temp_data" 2>/dev/null; then
    warn "Failed to generate complete context excluding $exclude_code"
    rm -f "$temp_data"
    return 1
  fi

  # Build context file with header, data, and footer
  {
    cat <<'CONTEXT'
=== CONTEXT: Full BCS Complete Standard for Cross-Reference ===

Below is the complete BASH-CODING-STANDARD in its full form (EXCLUDING the current rule being compressed). Use this to:

1. **Identify concepts already explained in other rules** - avoid duplicating explanations
2. **Maintain consistent terminology** across all rules (use same terms for same concepts)
3. **Reference related rules** where appropriate (e.g., "see BCS0205 for readonly pattern")
4. **Understand overall structure** - see how your rule fits into the bigger picture
5. **Deduplicate aggressively** - if concept X is explained in BCS01, don't re-explain in BCS08

CRITICAL: Use this context to eliminate cross-rule duplication. If a concept is already
clearly explained in another rule, reference it instead of repeating the explanation.

================================================================================

CONTEXT
    cat "$temp_data"
    cat <<'END_CONTEXT'

================================================================================

=== END CONTEXT ===

Now compress the target rule file with full awareness of the above context.
END_CONTEXT
  } > "$output_file"

  # Cleanup temp data file
  rm -f "$temp_data"
  return 0
}
declare -fx build_context_complete_exclude

# List all BCS codes with titles
cmd_codes() {
  # Handle --help
  if [[ "${1:-}" == '-h' || "${1:-}" == '--help' ]]; then
    cat <<EOF
$BCS_NAME codes - List all BCS rule codes

Usage: $BCS_NAME codes

Lists all BCS rule codes from the data/ directory tree.

Output format:
  BCS{code}:{shortname}:{title}

Example output:
  BCS010201:dual-purpose:Dual-Purpose Scripts (Executable and Sourceable)
  BCS0103:metadata:Script Metadata
  BCS0205:readonly-after-group:Readonly After Group Declaration

EOF
    return 0
  fi

  # Find data directory
  local -- data_dir
  data_dir=$(find_data_dir) || { error 'Data directory not found'; return 1; }

  # Find all abstract.md files and process them
  local -a files=()
  local -- file hdr shortname bcs_code

  readarray -t files < <(find "$data_dir" -type f -name '[0-9]*.abstract.md' | sort)

  if ((${#files[@]} == 0)); then
    error "No rule files found in '$data_dir'"
    return 1
  fi

  for file in "${files[@]}"; do
    # Get absolute path
    file=$(realpath -- "$file") || continue

    # Extract BCS code
    bcs_code=$(get_bcs_code "$file") || continue

    # Extract title from first line (remove # and trim)
    hdr=$(head -n1 "$file" | tr -d '#')
    hdr=$(trim <<<"$hdr")

    # Get shortname: basename without .abstract.md, then remove ##- prefix
    shortname=$(basename -s .abstract.md -- "$file")
    shortname="${shortname:3}"  # Remove ##- prefix

    # Output
    echo "$bcs_code:$shortname:$hdr"
  done
}
declare -fx cmd_codes

# Helper function to fix header level based on file depth
# Args: filepath data_dir
fix_header_level() {
  local -- filepath="$1"
  local -- data_dir="$2"
  local -- relative_path="${filepath#"$data_dir"/}"
  local -i slash_count depth
  local -- first_line header_text header_marker

  # Count directory separators to determine depth
  slash_count=$( (grep -o '/' <<<"$relative_path" || true) | wc -l)

  # Special case: 00-section files are depth 1 (section)
  if [[ $(basename "$filepath") =~ ^00-section\. ]]; then
    depth=1
  else
    # Depth 0: files directly in data/ (should not happen)
    # Depth 1: files in data/##-section/ (rules)
    # Depth 2+: files in data/##-section/##-rule/ (subrules)
    case $slash_count in
      0) depth=1 ;;  # Shouldn't happen, treat as section
      1) depth=2 ;;  # Rule level
      *) depth=3 ;;  # Subrule level
    esac
  fi

  # Get correct header marker
  case $depth in
    1) header_marker='#' ;;
    2) header_marker='##' ;;
    *) header_marker='###' ;;
  esac

  # Read first line
  first_line=$(head -n 1 "$filepath")

  # Check if first line is a header
  if [[ "$first_line" =~ ^#+[[:space:]] ]]; then
    # Extract header text (strip existing # markers)
    header_text=$(sed -E 's/^#+[[:space:]]*//' <<<"$first_line")
    # Output corrected header
    echo "$header_marker $header_text"
    # Output rest of file
    tail -n +2 "$filepath"
  else
    # First line is not a header, output file as-is
    cat "$filepath"
  fi
}

# Parse comma-separated exclusion list into array
# Args: exclusion_string array_name
# Returns: Populates named array with normalized BCS codes
parse_exclusion_list() {
  local -- exclusion_string="$1"
  local -- array_name="$2"
  local -a codes=()
  local -- code

  # Split by comma
  IFS=',' read -ra codes <<<"$exclusion_string"

  # Normalize each code (add BCS prefix if missing, uppercase)
  for code in "${codes[@]}"; do
    # Trim whitespace
    code=$(trim <<<"$code")

    # Skip empty codes
    [[ -z "$code" ]] && continue

    # Add BCS prefix if missing
    if [[ ! "$code" =~ ^BCS ]]; then
      code="BCS$code"
    fi

    # Store in named array using nameref
    eval "$array_name+=(\"$code\")"
  done
}
declare -fx parse_exclusion_list

# Check if a BCS code should be excluded based on exclusion patterns
# Args: bcs_code exclusion_array_name
# Returns: 0 if excluded, 1 if not excluded
is_excluded() {
  local -- bcs_code="$1"
  local -- array_name="$2"
  local -- pattern

  # Get array contents using nameref indirection
  #shellcheck disable=SC1087
  eval "local -a patterns=(\"\${$array_name[@]}\")"

  #shellcheck disable=SC2154 # patterns defined via eval
  for pattern in "${patterns[@]}"; do
    # Exact match or prefix match
    # BCS01 excludes BCS0101, BCS0102, etc.
    # BCS0102 excludes BCS0102, BCS010201, etc.
    if [[ "$bcs_code" == "$pattern"* ]]; then
      return 0
    fi
  done

  return 1
}
declare -fx is_excluded

# Filter md_files array based on exclusion patterns
# Usage: readarray -t md_files < <(filter_excluded_files md_files exclusion_codes)
# Returns: Outputs filtered file paths (one per line) and excluded count as last line prefixed with "EXCLUDED:"
filter_excluded_files() {
  local -- files_array_name="$1"
  local -- exclusion_array_name="$2"

  # Get current array contents
  #shellcheck disable=SC1087
  eval "local -a files=(\"\${$files_array_name[@]}\")"
  #shellcheck disable=SC1087
  eval "local -a exclusions=(\"\${$exclusion_array_name[@]}\")"

  # If no exclusions, output all files
  #shellcheck disable=SC2154 # patterns defined via eval
  if (( ${#exclusions[@]} == 0 )); then
    printf '%s\n' "${files[@]}"
    echo "EXCLUDED:0"
    return 0
  fi

  # Build new filtered array
  local -a filtered=()
  local -- file bcs_code basename_file
  local -i excluded_count=0

  for file in "${files[@]}"; do
    # Skip header files (never exclude these)
    basename_file=$(basename "$file")
    if [[ "$basename_file" =~ ^00-header\. ]]; then
      filtered+=("$file")
      continue
    fi

    # Get BCS code and check if excluded
    bcs_code=$(get_bcs_code "$file") || bcs_code=''

    if [[ -n "$bcs_code" ]] && is_excluded "$bcs_code" "$exclusion_array_name"; then
      excluded_count+=1
    else
      filtered+=("$file")
    fi
  done

  # Output filtered files
  printf '%s\n' "${filtered[@]}"
  echo "EXCLUDED:$excluded_count"
  return 0
}
declare -fx filter_excluded_files

# Regenerate BASH-CODING-STANDARD.md from data/ tree
cmd_generate() {
  # Parse arguments
  local -- output_file=''
  local -- file_type
  file_type=$(get_default_tier)  # Use symlink to determine default tier
  local -i use_stdout=1  # Default to stdout for safety
  local -i use_canonical=0
  local -i force_regenerate=0
  local -- exclusion_string=''
  local -a exclusion_codes=()

  while (($#)); do
    case $1 in
      -h|--help)
        cat <<'EOF'
bcs generate - Regenerate BASH-CODING-STANDARD.md from data/ tree

Usage: bcs generate [OPTIONS]

Options:
  -h, --help              Show this help message
  -t, --type TYPE         File type: complete, abstract, summary, rulet, abstract-complete (default: abstract)
  -o, --output FILE       Output to specific file
  -x, --exclude CODES     Exclude BCS codes (comma-separated, BCS prefix optional)
  --canonical             Generate all four tiers to BASH-CODING-STANDARD.{complete,summary,abstract,rulet}.md
  -f, --force             Force regeneration ignoring timestamps (use with --canonical)

Default behavior: Output to stdout (safe, non-destructive)

Examples:
  bcs generate                           # Generate abstract standard to stdout (default)
  bcs generate --canonical               # Generate all four tier files (complete, summary, abstract, rulet)
  bcs generate --canonical --force       # Force regeneration of all four tier files
  bcs generate -t complete               # Generate complete version to stdout
  bcs generate -t summary                # Generate summary version to stdout
  bcs generate -t rulet                  # Generate rulet version to stdout
  bcs generate -t abstract-complete      # Generate combined abstract+complete version
  bcs generate -t summary -o /tmp/BCS-summary.md
  bcs generate -x 0103,0201              # Exclude BCS0103 and BCS0201
  bcs generate -x BCS01 --tier summary   # Exclude entire Section 1 from summary
  bcs generate --exclude 0103,010201,02  # Exclude specific rules and Section 2

File types:
  complete          - Complete standard (*.complete.md files)
  abstract          - Abstract version (*.abstract.md files)
  summary           - Summary version (*.summary.md files)
  rulet             - Rulet version (*.rulet.md files - concise rules with BCS codes)
  abstract-complete - Combined: abstract then complete for each rule with formfeed separator

Exclusion pattern matching:
  - BCS prefix is optional: -x 0103 = -x BCS0103
  - Prefix matching: -x BCS01 excludes BCS0101, BCS0102, etc. (entire section)
  - Multiple codes: -x 0103,0201,010201 (comma-separated)
  - Works with all tiers and --canonical mode

Note: When using --canonical, all four tier files are generated and the BCS/ index is rebuilt.
      The BCS/ index contains symlinks with BCS codes (e.g., BCS0102.complete.md) for quick reference.
      The --force flag bypasses timestamp checks and regenerates all files unconditionally.

EOF
        return 0
        ;;
      -t|--type)
        arg2 "$@"; shift
        file_type="$1"
        ;;
      -o|--output)
        arg2 "$@"; shift
        output_file="$1"
        use_stdout=0
        ;;
      -x|--exclude)
        arg2 "$@"; shift
        exclusion_string="$1"
        ;;
      --canonical)
        use_canonical=1
        use_stdout=0
        ;;
      -f|--force)
        force_regenerate=1
        ;;
      -*)
        error "Unknown option ${1@Q}"
        return 22
        ;;
      *)
        error "Unknown argument ${1@Q}"
        return 2
        ;;
    esac
    shift
  done

  # Parse exclusion list if provided
  [[ -z "$exclusion_string" ]] || parse_exclusion_list "$exclusion_string" exclusion_codes

  # Special handling for --canonical: generate all three tiers
  if ((use_canonical)); then
    # Force regeneration if requested
    if ((force_regenerate)); then
      local -- data_dir
      data_dir=$(find_data_dir) || { error 'Data directory not found'; return 1; }

      info 'Force mode enabled - regenerating all compressed files...'

      # Call integrated compression system
      # Signature: data_dir tier claude_cmd dry_run compress_verbose summary_limit abstract_limit context_level force
      compress_process_all_rules "$data_dir" '' 'claude' 0 1 10000 1500 'none' 1 || {
        error 'Failed to regenerate compressed files' \
              'Aborting canonical generation'
        return 1
      }

      >&2 echo
    fi

    info 'Generating all four tiers for canonical files...'

    # Determine output directory (within data/)
    local -- data_dir
    data_dir=$(find_data_dir) || { error 'Data directory not found'; return 1; }
    local -- output_dir="$data_dir"

    # Generate complete tier
    file_type='complete'
    output_file="$output_dir"/BASH-CODING-STANDARD.complete.md

    # Find and validate files
    local -- suffix='.complete.md'
    local -a md_files=()

    readarray -t md_files < <(find "$data_dir" -name "*$suffix" -type f ! -name "README.md" ! -name "BASH-CODING-STANDARD.*" | sort)

    if ((${#md_files[@]} == 0)); then
      error "No complete files found in ${data_dir@Q}"
      return 1
    fi

    # Apply exclusions if provided
    local -i excluded_count=0
    if ((${#exclusion_codes[@]} > 0)); then
      local -- filter_output
      filter_output=$(filter_excluded_files md_files exclusion_codes)
      excluded_count=$(grep "^EXCLUDED:" <<<"$filter_output" | cut -d: -f2)
      readarray -t md_files < <(grep -v "^EXCLUDED:" <<<"$filter_output")
      if ((excluded_count > 0)); then
        >&2 echo
        info "Excluding $excluded_count rule$(s $excluded_count): ${exclusion_codes[*]}"
      fi
    fi

    info "Generating complete standard from ${#md_files[@]} files..."

    {
      local -- file bcs_code basename_file
      local -i first_iteration=1
      for file in "${md_files[@]}"; do
        if [[ $first_iteration -eq 1 ]]; then
          first_iteration=0
        else
          echo -en "\n\n---\n\n\f\n"
        fi

        # Check if this is the header file (00-header.md)
        basename_file=$(basename "$file")
        if [[ "$basename_file" =~ ^00-header\. ]]; then
          # Output header without Rule prefix
          fix_header_level "$file" "$data_dir"
        else
          # Output with Rule prefix for all other files
          bcs_code=$(get_bcs_code "$file") || bcs_code='BCS????'
          echo "**Rule: $bcs_code**"
          echo
          fix_header_level "$file" "$data_dir"
        fi
      done
      echo '#fin'
    } > "$output_file"

    success "Generated '$output_file'"
    info "Total lines: $(wc -l < "$output_file")"

    # Generate summary tier
    file_type='summary'
    output_file="$output_dir/BASH-CODING-STANDARD.summary.md"
    suffix='.summary.md'
    md_files=()

    readarray -t md_files < <(find "$data_dir" -name "*$suffix" -type f ! -name "README.md" ! -name "BASH-CODING-STANDARD.*" | sort)

    if ((${#md_files[@]} == 0)); then
      error "No summary files found in '$data_dir'"
      return 1
    fi

    # Apply exclusions if provided
    if ((${#exclusion_codes[@]} > 0)); then
      local -- filter_output
      filter_output=$(filter_excluded_files md_files exclusion_codes)
      excluded_count=$(grep "^EXCLUDED:" <<<"$filter_output" | cut -d: -f2)
      readarray -t md_files < <(grep -v "^EXCLUDED:" <<<"$filter_output")
      if ((excluded_count > 0)); then
        >&2 echo
        info "Excluding $excluded_count rule$(s $excluded_count): ${exclusion_codes[*]}"
      fi
    fi

    info "Generating summary standard from ${#md_files[@]} files..."

    {
      local -- file bcs_code basename_file
      local -i first_iteration=1
      for file in "${md_files[@]}"; do
        if [[ $first_iteration -eq 1 ]]; then
          first_iteration=0
        else
          echo -en "\n\n---\n\n\f\n"
        fi

        # Check if this is the header file (00-header.md)
        basename_file=$(basename "$file")
        if [[ "$basename_file" =~ ^00-header\. ]]; then
          # Output header without Rule prefix
          fix_header_level "$file" "$data_dir"
        else
          # Output with Rule prefix for all other files
          bcs_code=$(get_bcs_code "$file") || bcs_code='BCS????'
          echo "**Rule: $bcs_code**"
          echo
          fix_header_level "$file" "$data_dir"
        fi
      done
      echo '#fin'
    } > "$output_file"

    success "Generated '$output_file'"
    info "Total lines: $(wc -l < "$output_file")"

    # Generate abstract tier
    file_type='abstract'
    output_file="$output_dir/BASH-CODING-STANDARD.abstract.md"
    suffix='.abstract.md'
    md_files=()

    readarray -t md_files < <(find "$data_dir" -name "*$suffix" -type f ! -name "README.md" ! -name "BASH-CODING-STANDARD.*" | sort)

    if ((${#md_files[@]} == 0)); then
      error "No abstract files found in '$data_dir'"
      return 1
    fi

    # Apply exclusions if provided
    if ((${#exclusion_codes[@]} > 0)); then
      local -- filter_output
      filter_output=$(filter_excluded_files md_files exclusion_codes)
      excluded_count=$(grep "^EXCLUDED:" <<<"$filter_output" | cut -d: -f2)
      readarray -t md_files < <(grep -v "^EXCLUDED:" <<<"$filter_output")
      if ((excluded_count > 0)); then
        >&2 echo
        info "Excluding $excluded_count rule$(s $excluded_count): ${exclusion_codes[*]}"
      fi
    fi

    info "Generating abstract standard from ${#md_files[@]} files..."

    {
      local -- file bcs_code basename_file
      local -i first_iteration=1
      for file in "${md_files[@]}"; do
        if [[ $first_iteration -eq 1 ]]; then
          first_iteration=0
        else
          echo -en "\n\n---\n\n\f\n"
        fi

        # Check if this is the header file (00-header.md)
        basename_file=$(basename "$file")
        if [[ "$basename_file" =~ ^00-header\. ]]; then
          # Output header without Rule prefix
          fix_header_level "$file" "$data_dir"
        else
          # Output with Rule prefix for all other files
          bcs_code=$(get_bcs_code "$file") || bcs_code='BCS????'
          echo "**Rule: $bcs_code**"
          echo
          fix_header_level "$file" "$data_dir"
        fi
      done
      echo '#fin'
    } > "$output_file"

    success "Generated '$output_file'"
    info "Total lines: $(wc -l < "$output_file")"

    # Generate rulet tier
    file_type='rulet'
    output_file="$output_dir/BASH-CODING-STANDARD.rulet.md"
    suffix='.rulet.md'
    md_files=()

    readarray -t md_files < <(find "$data_dir" -name "*$suffix" -type f ! -name "README.md" ! -name "BASH-CODING-STANDARD.*" | sort)

    if ((${#md_files[@]} == 0)); then
      error "No rulet files found in '$data_dir'"
      return 1
    fi

    # Apply exclusions if provided
    if ((${#exclusion_codes[@]} > 0)); then
      local -- filter_output
      filter_output=$(filter_excluded_files md_files exclusion_codes)
      excluded_count=$(grep "^EXCLUDED:" <<<"$filter_output" | cut -d: -f2)
      readarray -t md_files < <(grep -v "^EXCLUDED:" <<<"$filter_output")
      if ((excluded_count > 0)); then
        >&2 echo
        info "Excluding $excluded_count rule$(s $excluded_count): ${exclusion_codes[*]}"
      fi
    fi

    info "Generating rulet standard from ${#md_files[@]} files..."

    {
      local -- file bcs_code basename_file
      local -i first_iteration=1
      for file in "${md_files[@]}"; do
        if [[ $first_iteration -eq 1 ]]; then
          first_iteration=0
        else
          echo -en "\n\n---\n\n\f\n"
        fi

        # Check if this is the header file (00-header.md)
        basename_file=$(basename "$file")
        if [[ "$basename_file" =~ ^00-header\. ]]; then
          # Output header without Rule prefix
          fix_header_level "$file" "$data_dir"
        else
          # Output with Rule prefix for all other files
          bcs_code=$(get_bcs_code "$file") || bcs_code='BCS????'
          echo "**Rule: $bcs_code**"
          echo
          fix_header_level "$file" "$data_dir"
        fi
      done
      echo '#fin'
    } > "$output_file"

    success "Generated '$output_file'"
    info "Total lines: $(wc -l < "$output_file")"

    success 'All four tiers generated'
    >&2 echo

    # Rebuild BCS/ index directory
    rebuild_bcs_index || {
      error 'Failed to rebuild BCS/ index'
      return 1
    }

    success 'BCS/ index rebuilt successfully'
    return 0
  fi

  # Validate file type for non-canonical mode
  case "$file_type" in
    complete|abstract|summary|abstract-complete|rulet) ;;
    *)
      error "Invalid file type '$file_type'"
      info 'Must be one of: complete, abstract, summary, rulet, abstract-complete'
      return 2
      ;;
  esac

  # Determine output file for non-canonical mode
  if ((use_stdout)); then
    output_file='/dev/stdout'
  elif [[ -z "$output_file" ]]; then
    # This shouldn't happen given logic above, but safety fallback
    output_file='/dev/stdout'
  fi

  # Determine file suffix
  local -- suffix
  case "$file_type" in
    complete)  suffix='.complete.md' ;;
    abstract)  suffix='.abstract.md' ;;
    summary)   suffix='.summary.md' ;;
    rulet)     suffix='.rulet.md' ;;
    abstract-complete) # Find abstract files, pair with complete
               suffix='.abstract-complete.md' ;;
  esac

  # Find data directory
  local -- data_dir
  data_dir=$(find_data_dir) || { error 'Data directory not found'; return 1; }

  # Find all matching files
  local -a md_files=()
  readarray -t md_files < <(find "$data_dir" -name "*$suffix" -type f ! -name 'README.md' | sort)

  if ((${#md_files[@]} == 0)); then
    error "No $file_type files found in ${data_dir@Q}"
    return 1
  fi

  # Apply exclusions if provided
  local -i excluded_count=0
  if ((${#exclusion_codes[@]})); then
    local -- filter_output
    filter_output=$(filter_excluded_files md_files exclusion_codes)
    excluded_count=$(grep "^EXCLUDED:" <<<"$filter_output" | cut -d: -f2)
    readarray -t md_files < <(grep -v "^EXCLUDED:" <<<"$filter_output")
    if ((excluded_count > 0)) && [[ "$output_file" != '/dev/stdout' ]]; then
      >&2 echo
      info "Excluding $excluded_count rule$(s $excluded_count): ${exclusion_codes[*]}"
    fi
  fi

  # For abstract-complete type, verify that each abstract file has a corresponding complete file
  if [[ "$file_type" == 'abstract-complete' ]]; then
    local -a verified_files=()
    local -- abstract_file complete_file
    for abstract_file in "${md_files[@]}"; do
      # Construct complete file path by replacing .abstract.md with .complete.md
      complete_file="${abstract_file%.abstract.md}.complete.md"
      if [[ -f "$complete_file" ]]; then
        verified_files+=("$abstract_file")
      else
        warn "Skipping ${abstract_file@Q} (no corresponding .complete.md)"
      fi
    done
    md_files=("${verified_files[@]}")

    if ((${#md_files[@]} == 0)); then
      error "No complete file pairs found in '${data_dir@Q}"
      return 1
    fi
  fi

  # Progress message to stderr (unless stdout mode)
  if [[ "$output_file" != '/dev/stdout' ]]; then
    info "Generating ${file_type@Q} standard from ${#md_files[@]} files..."
  fi

  # Generate output
  if [[ "$file_type" == 'abstract-complete' ]]; then
    # Special handling for abstract-complete: output abstract, then complete with formfeed separator
    {
      local -- abstract_file complete_file bcs_code
      local -i first_iteration=1
      for abstract_file in "${md_files[@]}"; do
        # Output formfeed separator before each rule (except first)
        if ((first_iteration)); then
          first_iteration=0
        else
          echo -en "\n\n---\n\n\f\n"
        fi

        # Extract and output BCS code reference at top of page
        bcs_code=$(get_bcs_code "$abstract_file") || bcs_code='BCS????'
        echo "**Rule: $bcs_code**"
        echo

        # Output abstract version
        cat "$abstract_file"
        echo

        # Output complete version
        complete_file="${abstract_file%.abstract.md}.complete.md"
        cat "$complete_file"
      done
      echo '#fin'
    } > "$output_file"
  else
    # Standard handling for complete/abstract/summary types with rule separation
    {
      local -- file bcs_code
      local -i first_iteration=1
      for file in "${md_files[@]}"; do
        # Output formfeed separator before each rule (except first)
        if ((first_iteration)); then
          first_iteration=0
        else
          echo -en "\n\n---\n\n\f\n"
        fi

        # Extract and output BCS code reference at top of page
        bcs_code=$(get_bcs_code "$file") || bcs_code='BCS????'
        echo "**Rule: $bcs_code**"
        echo

        # Output file content
        cat "$file"
      done
      echo '#fin'
    } > "$output_file"
  fi

  # Success message
  if [[ "$output_file" != '/dev/stdout' ]]; then
    success "Generated '$output_file'"
    info "Total lines: $(wc -l < "$output_file")"
  fi

  return 0
}
declare -fx cmd_generate

# Generate rulet files for all categories
cmd_generate_rulets() {
  # Parse arguments
  local -- category=''
  local -i batch_mode=0
  local -i force=0
  local -- agent_cmd
  agent_cmd=$(find_agent 'bcs-rulet-extractor') || agent_cmd=''

  while (($#)); do
    case $1 in
      -h|--help)
        cat <<'EOF'
bcs generate-rulets - Generate rulet files from complete.md rulefiles

Usage: bcs generate-rulets [OPTIONS] [CATEGORY]

Options:
  -h, --help              Show this help message
  -a, --all               Generate rulets for all 14 categories (batch mode)
  -f, --force             Force regeneration even if rulet file exists
  --agent-cmd CMD         Path to bcs-rulet-extractor agent (default: auto-detect from lib/agents/ or /ai/scripts/claude/agents/)

Arguments:
  CATEGORY                Category number (01-14) or name (e.g., 'variables', '02-variables')

Description:
  This command uses the bcs-rulet-extractor AI agent to read complete.md rulefiles
  and extract highly concise, actionable rulets with BCS code references.

  The agent analyzes all complete.md files in a category and generates a single
  00-{category-name}.rulet.md file containing extracted rules.

Examples:
  bcs generate-rulets 02                    # Generate rulets for category 02 (variables)
  bcs generate-rulets variables             # Same - by category name
  bcs generate-rulets 02-variables          # Same - by directory name
  bcs generate-rulets --all                 # Generate for all 14 categories
  bcs generate-rulets --all --force         # Force regeneration of all rulet files

Output:
  Rulet files are written to: data/{NN}-{category}/00-{category}.rulet.md

  Example: data/02-variables/00-variables.rulet.md

Requirements:
  - bcs-rulet-extractor agent (bundled in lib/agents/, auto-detected)
  - claude.x must be available in PATH

Note:
  Each rulet includes a BCS code reference in format [BCSXXXX] showing which
  source rule it was extracted from. Use 'bcs decode BCSXXXX' to view the full rule.

EOF
        return 0
        ;;
      -a|--all)
        batch_mode=1
        ;;
      -f|--force)
        force=1
        ;;
      --agent-cmd)
        arg2 "$@"; shift
        agent_cmd="$1"
        ;;
      -*)
        error "Unknown option ${1@Q}"
        return 22
        ;;
      *)
        category="$1"
        ;;
    esac
    shift
  done

  # Verify agent exists
  if [[ -z "$agent_cmd" || ! -x "$agent_cmd" ]]; then
    error 'bcs-rulet-extractor agent not found'
    info 'Expected locations:'
    info '  - lib/agents/bcs-rulet-extractor (bundled)'
    info '  - /ai/scripts/claude/agents/bcs-rulet-extractor (development)'
    info 'Or specify custom path with: --agent-cmd /path/to/bcs-rulet-extractor'
    return 1
  fi

  # Find data directory
  local -- data_dir
  data_dir=$(find_data_dir) || { error 'Data directory not found'; return 1; }

  # Batch mode: process all categories
  if ((batch_mode)); then
    info 'Batch mode: Generating rulets for all 14 categories...'

    local -a category_dirs=()
    readarray -t category_dirs < <(find "$data_dir" -maxdepth 1 -type d -name '[0-9][0-9]-*' | sort)

    if ((${#category_dirs[@]} == 0)); then
      error 'No category directories found in data/'
      return 1
    fi

    local -- dir category_num category_name
    local -i success_count=0
    local -i fail_count=0

    for dir in "${category_dirs[@]}"; do
      category_num=$(basename "$dir" | grep -o '^[0-9][0-9]')
      category_name=$(basename "$dir" | sed 's/^[0-9][0-9]-//')

      info "Processing category $category_num: $category_name"

      if generate_rulet_for_category "$dir" "$agent_cmd" "$force"; then
        ((success_count+=1))
      else
        ((fail_count+=1))
        warn "Failed to generate rulets for category $category_num"
      fi
    done

    >&2 echo
    success "Batch generation complete: $success_count successful, $fail_count failed"
    return 0
  fi

  # Single category mode
  if [[ -z "$category" ]]; then
    error 'No category specified. Use --all for batch mode or provide a category number/name.'
    info 'Examples: bcs generate-rulets 02, bcs generate-rulets variables, bcs generate-rulets --all'
    return 2
  fi

  # Resolve category to directory
  local -- category_dir
  category_dir=$(resolve_category_dir "$category" "$data_dir") || return 1

  # Generate rulet for this category
  generate_rulet_for_category "$category_dir" "$agent_cmd" "$force"
}
declare -fx cmd_generate_rulets

# Helper: Resolve category argument to directory path
resolve_category_dir() {
  local -- category="$1"
  local -- data_dir="$2"

  # Strip leading zeros and normalize
  category="${category#0}"  # Remove leading zero if present

  # Try exact match: NN-name
  if [[ -d "$data_dir/$category" ]]; then
    echo "$data_dir/$category"
    return 0
  fi

  # Try with zero-padding: 0N
  if [[ "$category" =~ ^[0-9]$ ]]; then
    local -- padded
    printf -v padded '%02d' "$category"
    local -a matches=()
    readarray -t matches < <(find "$data_dir" -maxdepth 1 -type d -name "${padded}-*")
    if ((${#matches[@]} == 1)); then
      echo "${matches[0]}"
      return 0
    fi
  fi

  # Try two-digit number
  if [[ "$category" =~ ^[0-9][0-9]$ ]]; then
    local -a matches=()
    readarray -t matches < <(find "$data_dir" -maxdepth 1 -type d -name "${category}-*")
    if ((${#matches[@]} == 1)); then
      echo "${matches[0]}"
      return 0
    fi
  fi

  # Try matching by name
  local -a matches=()
  readarray -t matches < <(find "$data_dir" -maxdepth 1 -type d -name "*-${category}")
  if ((${#matches[@]} == 1)); then
    echo "${matches[0]}"
    return 0
  elif ((${#matches[@]} > 1)); then
    error "Ambiguous category '$category' - multiple matches:"
    printf '  %s\n' "${matches[@]##*/}" >&2
    return 1
  fi

  error "Category not found: $category"
  info "Available categories (use number or name):"
  find "$data_dir" -maxdepth 1 -type d -name '[0-9][0-9]-*' | sort | while IFS= read -r dir; do
    printf '  %s\n' "$(basename "$dir")" >&2
  done
  return 1
}
declare -fx resolve_category_dir

# Helper: Generate rulet file for a specific category directory
generate_rulet_for_category() {
  local -- category_dir="$1"
  local -- agent_cmd="$2"
  local -i force="$3"

  local -- category_num category_name
  category_num=$(basename "$category_dir" | grep -o '^[0-9][0-9]')
  category_name=$(basename "$category_dir" | sed 's/^[0-9][0-9]-//')

  # Find all complete.md files (excluding 00-section.complete.md)
  local -a complete_files=()
  readarray -t complete_files < <(
    find "$category_dir" -maxdepth 2 -type f -name '[0-9][0-9]-*.complete.md' | sort
  )

  if ((${#complete_files[@]} == 0)); then
    warn "No complete.md files found in ${category_dir@Q}"
    return 1
  fi

  # Determine output file path
  local -- output_file="$category_dir"/00-"$category_name".rulet.md

  # Check if output already exists (unless force)
  if ((force == 0)) && [[ -f "$output_file" ]]; then
    info "Rulet file already exists ${output_file@Q} (use --force to regenerate)"
    return 0
  fi

  info "Found ${#complete_files[@]} complete.md files in category $category_num"

  # Build BCS code mapping for this category
  local -a bcs_codes=()
  local -- file file_base code
  for file in "${complete_files[@]}"; do
    # Extract BCS code from file path
    # data/02-variables/05-readonly-after-group.complete.md → BCS0205
    # data/02-variables/01-type-specific/01-integers.complete.md → BCS020101

    # Get relative path from data/
    local -- rel_path="${file#*/data/}"

    # Extract all numeric parts and concatenate
    code=$(echo "$rel_path" | grep -o '[0-9][0-9]' | tr -d '\n')
    code="BCS${code}"

    file_base=$(basename "$file")
    bcs_codes+=("  $code - $file_base")
  done

  # Create temporary prompt file with all complete.md contents
  local -- temp_input
  temp_input=$(mktemp) || { error 'Failed to create temp file'; return 1; }

  {
    echo "# BCS Category $category_num: $category_name"
    echo
    echo 'Extract rulets from the following complete.md files:'
    echo
    printf '%s\n' "${bcs_codes[@]}"
    echo
    echo '================================================================================'
    echo

    for file in "${complete_files[@]}"; do
      # Extract BCS code
      local -- rel_path="${file#*/data/}"
      code=$(echo "$rel_path" | grep -o '[0-9][0-9]' | tr -d '\n')
      code="BCS${code}"

      echo "### FILE: $code - $(basename -- "$file")"
      echo
      cat "$file"
      echo
      echo '================================================================================'
      echo
    done
  } > "$temp_input"

  # Invoke agent with retry logic for rate limit errors
  info "Invoking bcs-rulet-extractor agent..."

  local -i max_retries=3
  local -i retry_count=0
  local -i wait_time=5
  local -i success_flag=0

  while ((retry_count <= max_retries)); do
    # Create temp output file for this attempt
    local -- temp_output
    temp_output=$(mktemp)

    # Invoke agent (stderr redirected to capture error messages)
    local -- stderr_file
    stderr_file=$(mktemp)

    if "$agent_cmd" < "$temp_input" > "$temp_output" 2>"$stderr_file"; then
      # Strip ANSI escape sequences from output
      # Remove: ESC]..., ESC[..., and other control sequences
      sed -E 's/\x1B\[[0-9;]*[a-zA-Z]//g; s/\x1B\][^\x07]*\x07//g; s/\x1B\][^$]*$//g; /^[[:space:]]*$/d' "$temp_output" > "$output_file"

      # Check for API errors in output (rate limit, etc.)
      if grep -q "rate_limit_error\|API Error.*429" "$output_file"; then
        warn "API rate limit error detected in output"
        rm -f "$temp_output" "$stderr_file"

        if ((retry_count < max_retries)); then
          ((retry_count+=1))
          warn "Retry $retry_count/$max_retries after ${wait_time}s delay..."
          sleep "$wait_time"
          ((wait_time*=2))  # Exponential backoff
          continue
        else
          error 'Max retries reached - rate limit persists'
          rm -f "$temp_input" "$output_file"
          return 1
        fi
      fi

      # Validate output has actual rulets
      if ! grep -q '^\- \[BCS' "$output_file"; then
        warn 'Generated file contains no rulets (validation failed)'

        # Check if it's an error message
        if grep -q "Error:\|error\|failed" "$output_file"; then
          error 'Agent returned error output'
          cat "$output_file" >&2

          if ((retry_count < max_retries)); then
            retry_count+=1
            warn "Retry $retry_count/$max_retries after ${wait_time}s delay..."
            sleep "$wait_time"
            ((wait_time*=2))
            continue
          else
            rm -f "$temp_input" "$temp_output" "$stderr_file" "$output_file"
            return 1
          fi
        fi

        # Empty output - different error
        error "Output file is empty or contains no valid rulets"
        rm -f "$temp_input" "$temp_output" "$stderr_file" "$output_file"
        return 1
      fi

      # Success!
      rm -f "$temp_input" "$temp_output" "$stderr_file"
      success "Generated rulet file ${output_file@Q}"
      info "Lines: $(wc -l < "$output_file")"
      success_flag=1
      break

    else
      # Agent command failed
      local -i exit_code=$?
      error "Agent command failed with exit code $exit_code"

      # Check stderr for rate limit
      if grep -q "rate_limit\|429" "$stderr_file"; then
        warn 'Rate limit detected in stderr'
        cat "$stderr_file" >&2

        if ((retry_count < max_retries)); then
          ((retry_count+=1))
          warn "Retry $retry_count/$max_retries after ${wait_time}s delay..."
          sleep "$wait_time"
          ((wait_time*=2))
          rm -f "$temp_output" "$stderr_file"
          continue
        fi
      fi

      rm -f "$temp_input" "$temp_output" "$stderr_file"
      error "Agent failed to generate rulets for category $category_num"
      return 1
    fi
  done

  if ((success_flag)); then
    return 0
  else
    error "Failed to generate rulets after $max_retries retries"
    return 1
  fi
}
declare -fx generate_rulet_for_category

# Search within the standard
cmd_search() {
  # Parse arguments
  local -- pattern=''
  local -i ignore_case=0
  local -i context_lines=3

  while (($#)); do
    case $1 in
      -h|--help)
        cat <<'EOF'
bcs search - Search within the Bash Coding Standard

Usage: bcs search [OPTIONS] PATTERN

Options:
  -h, --help              Show this help message
  -i, --ignore-case       Case-insensitive search
  -C NUM                  Show NUM lines of context (default: 3)

Examples:
  bcs search readonly                    # Search for "readonly"
  bcs search -i "SET -E"                 # Case-insensitive search
  bcs search -C 5 "declare -fx"          # Search with 5 lines of context
  bcs search "BCS0205"                   # Search for specific code reference

EOF
        return 0
        ;;
      -i|--ignore-case)
        ignore_case=1
        ;;
      -C)
        arg2_num "$@"; shift
        context_lines="$1"
        ;;
      -*)
        error "Unknown option ${1@Q}"
        return 22
        ;;
      *)
        pattern="$1"
        break
        ;;
    esac
    shift
  done

  # Validate pattern provided
  if [[ -z "$pattern" ]]; then
    error 'No search pattern specified'
    info 'Usage: bcs search [OPTIONS] PATTERN'
    return 2
  fi

  # Check BCS_FILE exists
  if [[ ! -f "$BCS_FILE" ]]; then
    error "Standard file not found ${BCS_FILE@Q}"
    return 1
  fi

  # Build grep command
  local -a grep_args=(-C "$context_lines" --color=auto -n)
  ((ignore_case)) && grep_args+=(-i)

  # Execute grep
  if grep "${grep_args[@]}" -- "$pattern" "$BCS_FILE"; then
    return 0
  else
    info "No matches found for '$pattern'"
    return 1
  fi
}
declare -fx cmd_search

# Helper: Find BCS file by code and tier
# Returns absolute path to matching file, or empty string if not found
find_bcs_file_by_code() {
  local -- code=$1
  local -- tier="${2:-abstract}"
  local -- data_dir
  data_dir=$(find_data_dir) || return 1

  # Validate inputs
  [[ -n "$code" ]] || return 2
  [[ -d "$data_dir" ]] || return 1

  # Normalize code (remove BCS prefix if present, ensure uppercase)
  code="${code^^}"
  code="${code#BCS}"

  # Determine file suffix
  local -- suffix
  case "$tier" in
    complete)   suffix='.complete.md' ;;
    abstract)   suffix='.abstract.md' ;;
    summary)    suffix='.summary.md' ;;
    rulet)      # Rulet files only exist at section level (00-*.rulet.md)
                # Only 2-digit section codes are valid (e.g., BCS02)
                if [[ ${#code} -ne 2 ]]; then
                  # Rule codes (4+ digits) not supported for rulet tier
                  return 2
                fi
                suffix='.rulet.md'
                ;;
    *) return 2 ;;
  esac

  # Handle BCS00 specially - the header file (top-level, not in a subdirectory)
  if [[ "$code" == '00' ]]; then
    local -- header_file="$data_dir"/00-header"$suffix"
    if [[ -f "$header_file" ]]; then
      echo "$header_file"
      return 0
    fi
    return 1
  fi

  # Handle section codes (2-digit codes like BCS01, BCS02, etc.)
  # These map to 00-section.{tier}.md files in the section directory
  # For rulet tier, map to 00-{category-name}.rulet.md files
  if [[ "$code" =~ ^[0-9][0-9]$ ]]; then
    # Find the section directory (e.g., 01-script-structure for code "01")
    local -- section_dir
    section_dir=$(find "$data_dir" -maxdepth 1 -type d -name "$code-*" -print -quit)

    if [[ -n "$section_dir" && -d "$section_dir" ]]; then
      if [[ "$tier" == 'rulet' ]]; then
        # For rulet tier, look for 00-{category-name}.rulet.md file
        local -- rulet_file
        rulet_file=$(find "$section_dir" -maxdepth 1 -type f -name "00-*.rulet.md" -print -quit)
        if [[ -n "$rulet_file" && -f "$rulet_file" ]]; then
          echo "$rulet_file"
          return 0
        fi
      else
        # Look for 00-section.{tier}.md file
        local -- section_file="$section_dir"/00-section$suffix
        if [[ -f "$section_file" ]]; then
          echo "$section_file"
          return 0
        fi
      fi
    fi

    # Section code not found
    return 1
  fi

  # Search for matching file by BCS code
  local -- file file_code

  while IFS= read -r -d '' file; do
    file_code=$(get_bcs_code "$file") || continue
    file_code="${file_code#BCS}"  # Remove BCS prefix

    if [[ "$file_code" == "$code" ]]; then
      echo "$file"
      return 0
    fi
  done < <(find "$data_dir" -type f -name "*$suffix" -print0)

  return 1
}
declare -fx find_bcs_file_by_code

# Parse comma-separated BCS codes, validate, and return array
parse_codes_option() {
  local -- codes_str="$1"
  local -a codes=()
  local -- code

  # Split on comma, handle spaces
  IFS=',' read -ra codes <<< "$codes_str"

  # Validate each code
  local -a valid_codes=()
  for code in "${codes[@]}"; do
    # Trim whitespace
    code=$(trim <<< "$code")

    # Normalize code (add BCS prefix if missing, uppercase)
    [[ "$code" =~ ^[0-9] ]] && code="BCS$code"
    code="${code^^}"

    # Validate code exists
    if find_bcs_file_by_code "${code#BCS}" 'abstract' &>/dev/null; then
      valid_codes+=("$code")
    else
      error "Invalid BCS code '$code'"
      info "Use 'bcs codes' to list all available codes"
      return 1
    fi
  done

  # Output valid codes
  printf '%s\n' "${valid_codes[@]}"
  return 0
}
declare -fx parse_codes_option

# Parse comma-separated section numbers, convert to BCS code prefixes
parse_sections_option() {
  local -- sections_str="$1"
  local -a sections=()
  local -- section

  # Split on comma, handle spaces
  IFS=',' read -ra sections <<< "$sections_str"

  # Convert each section number to BCS code prefix
  local -a code_prefixes=()
  for section in "${sections[@]}"; do
    # Trim whitespace
    section=$(trim <<< "$section")

    # Validate section number (1-14)
    if [[ ! "$section" =~ ^[0-9]+$ ]] || ((section < 0 || section > 14)); then
      error "Invalid section number ${section@Q} (must be 0-14)"
      return 1
    fi

    # Convert to zero-padded prefix (Section 1 → BCS01)
    printf -v code_prefix 'BCS%02d' "$section"
    code_prefixes+=("$code_prefix")
  done

  # Output code prefixes
  printf '%s\n' "${code_prefixes[@]}"
  return 0
}
declare -fx parse_sections_option

# Load BCS rules filtered by codes or sections
load_filtered_rules() {
  local -- tier="${1:-abstract}"
  shift
  local -a filters=("$@")

  # Validate tier
  case "$tier" in
    complete|abstract|summary|rulet) ;;
    *)
      error "Invalid tier ${tier@Q} (must be complete, abstract, summary, or rulet)"
      return 2
      ;;
  esac

  # If no filters, load full standard
  if ((${#filters[@]} == 0)); then
    case "$tier" in
      complete) cat "$BCS_FILE" ;;
      abstract|summary)
        # Generate on-the-fly using cmd_generate logic
        local -- suffix
        [[ "$tier" == 'abstract' ]] && suffix='.abstract.md' || suffix='.summary.md'

        local -- data_dir
        data_dir=$(find_data_dir) || return 1
        local -a md_files=()
        readarray -t md_files < <(find "$data_dir" -name "*$suffix" -type f ! -name 'README.md' | sort)

        for file in "${md_files[@]}"; do
          cat "$file"
          echo
        done
        ;;
      rulet)
        # Load all *.rulet.md files (section-level files)
        local -- data_dir
        data_dir=$(find_data_dir) || return 1
        local -a md_files=()
        readarray -t md_files < <(find "$data_dir" -name '*.rulet.md' -type f ! -name README.md ! -name 'BASH-CODING-STANDARD.*' | sort)

        for file in "${md_files[@]}"; do
          cat "$file"
          echo
        done
        ;;
    esac
    return 0
  fi

  # Load filtered rules
  local -- filter file code
  local -i found_any=0

  for filter in "${filters[@]}"; do
    # Normalize filter (remove BCS prefix, uppercase)
    filter="${filter^^}"
    filter="${filter#BCS}"

    # Find all codes matching this filter (prefix match for sections)
    while IFS=: read -r code _; do
      code="${code#BCS}"

      # Check if code matches filter (exact or prefix for sections)
      if [[ "$code" == "$filter" || "$code" == "$filter"* ]]; then
        file=$(find_bcs_file_by_code "$code" "$tier" 2>/dev/null) || continue

        # Output rule with BCS code header
        echo "**Rule: BCS$code**"
        echo
        cat "$file"
        echo
        echo '---'
        echo
        found_any+=1
      fi
    done < <(cmd_codes 2>/dev/null)
  done

  if ((found_any == 0)); then
    error "No rules found matching filters ${filters[*]@Q}"
    return 1
  fi

  return 0
}
declare -fx load_filtered_rules

# Build validation system prompt with optional filtering and tier selection
build_validation_prompt() {
  local -- tier="${1:-abstract}"
  local -- output_format="${2:-text}"
  shift 2
  local -a filters=("$@")

  # Start with base prompt header
  cat <<PROMPT_HEADER
You are a Bash script compliance validator for the Bash Coding Standard (BCS).

Your task is to analyze the provided bash script against the rules defined in
the BASH-CODING-STANDARD document that follows.

Analysis requirements:
1. Check compliance with applicable sections of the standard
2. Identify violations, warnings, and provide suggestions
3. Reference specific line numbers for each finding
4. Reference specific BCS codes for each finding (e.g., BCS0102, BCS0205)
5. Explain WHY each issue matters (don't just list rule violations)

Output format based on severity:
  ✓ COMPLIANT: [BCS Code - Section/Rule] - Brief explanation
  ✗ VIOLATION: [BCS Code - Section/Rule] - Critical issue at line X
  ⚠ WARNING: [BCS Code - Section/Rule] - Potential issue at line Y
  💡 SUGGESTION: [Best practice] - Improvement at line Z

Focus areas (when applicable):
  • BCS01 - Script Structure: shebang, set options, shopt, metadata, function organization
  • BCS02 - Variables: declarations, scoping, naming, readonly usage
  • BCS03 - Expansion: parameter expansion, brace usage
  • BCS04 - Quoting: single vs double quotes, variable quoting in conditionals
  • BCS05 - Arrays: declaration, iteration, safe list handling
  • BCS06 - Functions: naming, main() pattern, organization
  • BCS07 - Control Flow: [[ ]] usage, arithmetic, case statements
  • BCS08 - Error Handling: set -e, exit codes, traps, return values
  • BCS09 - I/O: STDERR vs STDOUT placement, messaging functions
  • BCS10 - Arguments: parsing patterns, validation
  • BCS11 - File Operations: wildcards, process substitution
  • BCS12 - Security: PATH, SUID/SGID, eval, input sanitization
  • BCS13 - Style: indentation, comments (WHY not WHAT), blank lines
  • BCS14 - Advanced: dry-run patterns, state management, testing support

PROMPT_HEADER

  # Add filtering notice if applicable
  if ((${#filters[@]} > 0)); then
    echo
    echo '**IMPORTANT: Validate ONLY against the following BCS codes/sections:**'
    printf '  - %s\n' "${filters[@]}"
    echo
    echo 'Do not report violations for rules outside this scope.'
    echo
  fi

  # Add standard content
  echo
  echo '---'
  echo
  echo '# Bash Coding Standard (BCS) Rules'
  echo

  # Load rules (filtered or full)
  if ((${#filters[@]})); then
    load_filtered_rules "$tier" "${filters[@]}"
  else
    load_filtered_rules "$tier"
  fi

  # Add format-specific instructions
  case "$output_format" in
    json|bcs-json)
      cat <<'JSON_INSTRUCTIONS'

---

OUTPUT FORMAT: JSON

Provide output as valid JSON with this exact structure:
{
  "file": "filename",
  "validation_scope": {
    "codes": ["BCS01", "BCS02"],
    "tier": "abstract|complete",
    "timestamp": "ISO8601 timestamp"
  },
  "findings": {
    "compliant": [
      {"code": "BCS0101", "rule": "Standard Script Layout", "message": "Script follows 13-step structure"}
    ],
    "violations": [
      {"line": 15, "code": "BCS0102", "rule": "Shebang", "severity": "critical", "message": "Missing set -euo pipefail"}
    ],
    "warnings": [
      {"line": 23, "code": "BCS0203", "rule": "Naming", "severity": "warning", "message": "Variable should be UPPER_CASE"}
    ],
    "suggestions": [
      {"line": 45, "code": null, "message": "Consider using readonly for constants"}
    ]
  },
  "summary": {
    "violations_count": 1,
    "warnings_count": 1,
    "suggestions_count": 1,
    "compliant_count": 15,
    "compliance_percentage": 93,
    "assessment": "compliant|needs_work|non_compliant"
  }
}
JSON_INSTRUCTIONS
      ;;
    markdown)
      cat <<'MARKDOWN_INSTRUCTIONS'

---

OUTPUT FORMAT: MARKDOWN

Provide output as well-formatted Markdown with:
- Title: # BCS Compliance Report: filename
- Summary section with statistics
- Detailed findings organized by BCS code
- Code examples where relevant
- Actionable recommendations at the end

Use BCS code references in all findings (e.g., **BCS0102 - Shebang and Initial Setup**).
MARKDOWN_INSTRUCTIONS
      ;;
    text)
      # Text format uses standard symbols (default)
      ;;
  esac

  # Add summary requirements
  cat <<'EOF_SUMMARY'

---

SUMMARY REQUIREMENTS:

Provide a summary with:
  • Count of violations (critical issues that must be fixed)
  • Count of warnings (potential issues or minor violations)
  • Count of suggestions (improvements and best practices)
  • Compliance percentage (compliant findings / total applicable rules)
  • Overall assessment: compliant, needs_work, or non_compliant
  • Exit code recommendation: 0 (compliant), 1 (warnings only), 2 (violations)

Reference BCS codes in all findings. Be specific about line numbers.
EOF_SUMMARY
}
declare -fx build_validation_prompt

# Build Claude command with advanced options
build_claude_command() {
  local -- system_prompt_file="$1"
  local -- append_prompt="${2:-}"
  local -- allowed_tools="${3:-}"
  local -- add_dir="${4:-}"
  local -i skip_permissions="${5:-0}"
  local -- claude_cmd="${6:-claude}"

  # Base command
  local -a claude_args=("$claude_cmd" --print --dangerously-skip-permissions)

  # System prompt (required)
  claude_args+=(--system-prompt "$system_prompt_file")

  # Append prompt (optional)
  if [[ -n "$append_prompt" ]]; then
    claude_args+=(--append-system-prompt "$append_prompt")
  fi

  # Restrict tools for safety (optional)
  if [[ -n "$allowed_tools" ]]; then
    claude_args+=(--allowedTools "$allowed_tools")
  fi

  # Add directory for context (optional)
  if [[ -n "$add_dir" ]]; then
    claude_args+=(--add-dir "$add_dir")
  fi

  # Skip permissions (sandbox mode)
  if ((skip_permissions)); then
    claude_args+=(--dangerously-skip-permissions)
  fi

  # Output the command array
  printf '%s\n' "${claude_args[@]}"
}
declare -fx build_claude_command

# Decode BCS code to file location
cmd_decode() {
  # Parse arguments
  local -a codes=()
  local -- tier output_format=absolute
  tier=$(get_default_tier)  # Use symlink to determine default tier
  local -i show_all=0 check_exists=0 print_contents=0

  while (($#)); do
    case $1 in
      -h|--help)
        cat <<'EOF'
bcs decode - Decode BCS code to file location

Usage: bcs decode [OPTIONS] CODE [CODE...]

Options:
  -h, --help              Show this help message
  -a, --abstract          Show abstract tier file location (default)
  -s, --summary           Show summary tier file location
  -c, --complete          Show complete tier file location
  -r, --rulet             Show rulet tier file location (section-level only)
  -p, --print             Print file contents to stdout instead of path
  --all                   Show all three tier file locations (or contents with -p)
  --relative              Output path relative to repository root
  --basename              Output only the filename
  --exists                Exit 0 if code exists, 1 if not (no output)

Arguments:
  CODE                    One or more BCS codes (e.g., BCS010201 or 010201)
                          Note: Rulet tier only supports section codes (2-digit like BCS02)

Description:
  Resolves BCS rule code to its source file location in the data/ directory.
  This is the inverse operation of get_bcs_code() - converting code back to file path.

  Important: Rulet tier files only exist at section level (00-*.rulet.md), not
  individual rule level. When using --rulet, only 2-digit section codes (like
  BCS02) are valid. Rule codes (4+ digits like BCS0205) will not be found.

Examples:
  bcs decode BCS010201                       # Show abstract tier absolute path
  bcs decode 010201                          # BCS prefix optional
  bcs decode BCS01                           # Section code - shows 00-section file
  bcs decode BCS0205 --relative              # Show relative path from repo root
  bcs decode BCS0102 --all                   # Show all three tier locations
  bcs decode BCS0103 --basename              # Show only filename
  bcs decode BCS0102 -p                      # Print rule contents to stdout
  bcs decode BCS0102 --all -p                # Print all three tiers with separators
  bcs decode BCS01 BCS02 BCS08 -p            # Print multiple sections
  bcs decode BCS9999 --exists && echo "exists"  # Check if code exists (scripting)

Use cases:
  vim $(bcs decode BCS0205)                  # Open rule file in editor
  bcs decode BCS0102 -p                      # View rule content directly
  bcs decode BCS0102 -p | less               # View with pager
  diff <(bcs decode BCS0102 -a -p) <(bcs decode BCS0102 -c -p)  # Compare tiers

EOF
        return 0
        ;;
      -a|--abstract)
        tier='abstract'
        ;;
      -s|--summary)
        tier='summary'
        ;;
      -c|--complete)
        tier='complete'
        ;;
      -r|--rulet)
        tier='rulet'
        ;;
      -p|--print)
        print_contents=1
        ;;
      --all)
        show_all=1
        ;;
      --relative)
        output_format='relative'
        ;;
      --basename)
        output_format='basename'
        ;;
      --exists)
        check_exists=1
        ;;
      -*)
        error "Unknown option ${1@Q}"
        return 2
        ;;
      *)
        #shellcheck disable=SC2206 # $n parameters are *always* one token
        codes+=($1)
        ;;
    esac
    shift
  done

  # Validate at least one code provided
  ((${#codes[@]})) || {
    error 'No BCS code specified'
    info 'Usage: bcs decode [OPTIONS] CODE [CODE...]'
    return 2
  }

  # Helper to format output based on format option
  format_output() {
    local -- file="$1"
    case "$output_format" in
      absolute)
        echo "$file"
        ;;
      relative)
        echo "${file#"$BCS_DIR"/}"
        ;;
      basename)
        basename "$file"
        ;;
    esac
  }

  # Loop through each code and process
  local -- code
  local -i code_index=0 total_found=0

  for code in "${codes[@]}"; do
    # Add separator between codes (when multiple codes and print mode)
    if ((code_index > 0)) && ((print_contents)); then
      echo
      echo '========================================='
      echo
    fi

    # Process based on options
    if ((show_all)); then
      # Show all tiers
      local -i found=0
      local -- file

      for tier in complete abstract summary rulet; do
        file=$(find_bcs_file_by_code "$code" "$tier" 2>/dev/null) || continue
        found+=1
        total_found+=1

        if ((check_exists)); then
          continue  # Just counting, don't output
        fi

        if ((print_contents)); then
          # Print contents with tier separator
          if ((found > 1)); then
            echo  # Blank line between tiers
            echo '---'
            echo
          fi
          echo "### $(tr '[:lower:]' '[:upper:]' <<<"${tier:0:1}")${tier:1} tier (BCS${code#BCS})"
          echo
          cat "$file"
        else
          # Print file path
          case "$output_format" in
            absolute|relative|basename)
              printf '%-9s: %s\n' "$(tr '[:lower:]' '[:upper:]' <<<"${tier:0:1}")${tier:1}" "$(format_output "$file")"
              ;;
          esac
        fi
      done

      # For this code, check if we found anything
      if ((found == 0)) && ! ((check_exists)); then
        error "BCS code not found '${code#BCS}'"
        info "Use 'bcs codes' to list all available codes"
      fi

    else
      # Single tier mode
      local -- file
      file=$(find_bcs_file_by_code "$code" "$tier" 2>/dev/null) || {
        if ! ((check_exists)); then
          error "BCS code not found: ${code#BCS} ($tier tier)"
          info "Use 'bcs codes' to list all available codes"
        fi
        code_index+=1
        continue
      }

      total_found+=1

      if ! ((check_exists)); then
        if ((print_contents)); then
          cat "$file"
        else
          format_output "$file"
        fi
      fi
    fi

    code_index+=1
  done

  # Return based on check_exists mode or total found count
  if ((check_exists)); then
    ((total_found > 0)) && return 0 || return 1
  fi

  ((total_found > 0)) && return 0 || return 1
}
declare -fx cmd_decode

# List all sections
cmd_sections() {
  # Handle --help
  if [[ "${1:-}" == '-h' || "${1:-}" == '--help' ]]; then
    cat <<'EOF'
bcs sections - List all sections of the Bash Coding Standard

Usage: bcs sections

Lists all 14 sections of the standard with their titles.

Example output:
  1. Script Structure & Layout
  2. Variable Declarations & Constants
  3. Variable Expansion & Parameter Substitution
  ...

EOF
    return 0
  fi

  # Check BCS_FILE exists
  if [[ ! -f "$BCS_FILE" ]]; then
    error "Standard file not found '$BCS_FILE'"
    return 1
  fi

  # Extract main section headers (those preceded by **Rule: BCS##00**)
  # Section codes end in 00: BCS0100, BCS0200, etc.
  # Pattern: **Rule: BCS##00** \n (blank) \n ## Section Name
  local -i count=0
  local -- line prev_line='' prev_prev_line=''

  while IFS= read -r line; do
    # Check if line 2 back was a section code (BCS##00) and current line is a # header
    if [[ "$prev_prev_line" =~ ^\*\*Rule:\ BCS[0-9]+00\*\*$ && "$line" =~ ^#\  ]]; then
      # This # header is a section header
      count+=1
      echo "$count. ${line#\# }"
    fi
    prev_prev_line="$prev_line"
    prev_line="$line"
  done < "$BCS_FILE"

  if ((count == 0)); then
    error "No sections found in $BCS_FILE"
    return 1
  fi

  return 0
}
declare -fx cmd_sections

# Set or show the default tier
cmd_default() {
  # Handle --help
  if [[ "${1:-}" == '-h' || "${1:-}" == '--help' ]]; then
    cat <<'EOF'
bcs default - Set or show the default tier

Usage: bcs default [TIER|OPTIONS]

Arguments:
  TIER                    Tier to set as default: complete, summary, abstract, or rulet

Options:
  -h, --help              Show this help message
  -l, --list              List all available tiers with current default marked

When called without arguments, shows the current default tier.

Examples:
  bcs default                    # Show current default tier
  bcs default complete           # Set default to complete tier
  bcs default --list             # List all available tiers
  bcs default rulet              # Set default to rulet tier

The default tier is determined by the BASH-CODING-STANDARD.md symlink target.

EOF
    return 0
  fi

  # Handle --list
  if [[ "${1:-}" == '-l' || "${1:-}" == '--list' ]]; then
    local -- current_tier
    current_tier=$(get_default_tier)

    local -- tier
    for tier in complete summary abstract rulet; do
      if [[ "$tier" == "$current_tier" ]]; then
        echo "$tier *"
      else
        echo "$tier"
      fi
    done

    return 0
  fi

  # No argument: show current default
  if (($# == 0)); then
    local -- current_tier
    current_tier=$(get_default_tier)
    echo "$current_tier"
    return 0
  fi

  # Argument provided: set new default
  local -- new_tier="$1"

  # Validate tier argument
  case "$new_tier" in
    complete|summary|abstract|rulet)
      # Valid tier
      ;;
    *)
      error "Invalid tier '$new_tier'"
      info 'Valid tiers: complete, summary, abstract, rulet'
      return 2
      ;;
  esac

  # Check write permissions
  if [[ ! -w "$BCS_DIR" ]]; then
    error "Permission denied: Cannot write to $BCS_DIR"
    info 'Try running with sudo or as the owner of the directory'
    return 1
  fi

  # Verify target file exists
  local -- target_file="$BCS_DIR/data/BASH-CODING-STANDARD.${new_tier}.md"
  if [[ ! -f "$target_file" ]]; then
    error "Target file not found: $target_file"
    return 1
  fi

  # Get current default before changing
  local -- old_tier
  old_tier=$(get_default_tier)

  # Check if already set to this tier
  if [[ "$old_tier" == "$new_tier" ]]; then
    info "Default tier is already set to ${CYAN}${new_tier}${NC}"
    return 0
  fi

  # Create the symlink (relative path for portability)
  local -- symlink_path="$BCS_DIR/data/BASH-CODING-STANDARD.md"
  local -- relative_target="BASH-CODING-STANDARD.${new_tier}.md"

  if ! ln -sf "$relative_target" "$symlink_path"; then
    error "Failed to create symlink"
    return 1
  fi

  # Show before/after information
  success "Changed default tier from ${CYAN}${old_tier}${NC} to ${CYAN}${new_tier}${NC}"

  return 0
}
declare -fx cmd_default

# Display project information
cmd_about() {
  # Parse arguments
  local -i show_stats=0 show_links=0 show_verbose=0 show_quote=0 show_json=0

  while (($#)); do
    case $1 in
      -h|--help)
        cat <<'EOF'
bcs about - Display Bash Coding Standard project information

Usage: bcs about [OPTIONS]

Options:
  -h, --help              Show this help message
  -s, --stats             Show statistics only
  -l, --links             Show links and references only
  -v, --verbose           Show all information (default + stats + links)
  -q, --quote             Show philosophy quote and principles only
  --json                  Output as JSON for scripting

Examples:
  bcs about                              # Show general information
  bcs about --stats                      # Show statistics only
  bcs about --verbose                    # Show complete information
  bcs about --json | jq -r '.version'    # Get version programmatically

EOF
        return 0
        ;;
      -s|--stats)
        show_stats=1
        ;;
      -l|--links)
        show_links=1
        ;;
      -v|--verbose)
        show_verbose=1
        ;;
      -q|--quote)
        show_quote=1
        ;;
      --json)
        show_json=1
        ;;
      *)
        error "Unknown option ${1@Q}"
        return 2
        ;;
    esac
    shift
  done

  # Gather statistics
  local -i sections_count=0 rules_count=0 lines_count=0 source_files_count=0 test_files_count=0
  local -- data_dir
  data_dir=$(find_data_dir) 2>/dev/null || data_dir=''

  if [[ -d "$data_dir" ]]; then
    sections_count=$(find "$data_dir" -maxdepth 1 -type d -name '[0-9][0-9]-*' 2>/dev/null | wc -l)
    rules_count=$(cmd_codes 2>/dev/null | wc -l)
    source_files_count=$(find "$data_dir" -type f -name '*.md' 2>/dev/null | wc -l)
  fi

  if [[ -f "$BCS_FILE" ]]; then
    lines_count=$(wc -l < "$BCS_FILE")
  fi

  if [[ -d "$BCS_DIR/tests" ]]; then
    test_files_count=$(find "$BCS_DIR/tests" -type f -name 'test-*.sh' 2>/dev/null | wc -l)
  fi

  # JSON output
  if ((show_json)); then
    cat <<EOF
{
  "name": "Bash Coding Standard",
  "abbreviation": "BCS",
  "version": "$BCS_VERSION",
  "bash_version": "5.2+",
  "description": "A comprehensive coding standard for modern Bash scripts",
  "philosophy": "This isn't just a coding standard - it's a systems engineering philosophy applied to Bash.",
  "author": "Biksu Okusi",
  "statistics": {
    "sections": $sections_count,
    "rules": $rules_count,
    "lines": {
      "full": $lines_count
    },
    "source_files": $source_files_count,
    "test_files": $test_files_count
  },
  "organizations": {
    "developer": "Okusi Associates",
    "adopter": "Indonesian Open Technology Foundation (YaTTI)"
  },
  "license": "CC BY-SA 4.0",
  "repository": "https://github.com/OkusiAssociates/bash-coding-standard",
  "references": {
    "google_style": "https://google.github.io/styleguide/shellguide.html",
    "shellcheck": "https://www.shellcheck.net/",
    "bash_manual": "https://www.gnu.org/software/bash/manual/bash.html"
  }
}
EOF
    return 0
  fi

  # Quote-only output
  if ((show_quote)); then
    cat <<'EOF'

"This isn't just a coding standard - it's a systems engineering philosophy
applied to Bash."
                                                        -- Biksu Okusi

Coding Principles:
  • K.I.S.S. (Keep It Simple, Stupid)
  • "The best process is no process"
  • "Everything should be made as simple as possible, but not any simpler."

NOTE: Do not over-engineer scripts; functions and variables not required
for the operation of the script should not be included and/or removed.

EOF
    return 0
  fi

  # Stats-only output
  if ((show_stats)); then
    cat <<EOF

=== Bash Coding Standard Statistics ===

Structure:
  Sections:           $sections_count
  Rules:              $rules_count BCS codes

Documentation:
  Standard size:      $lines_count lines (full)
  Source files:       $source_files_count .md files in data/
  Data directory:     $sections_count section director$(y "$sections_count")

Code Quality:
  Test files:         $test_files_count comprehensive test scripts
  ShellCheck:         All scripts pass validation

Repository:
  Main script:        bash-coding-standard (v$BCS_VERSION)
  Subcommands:        11 (display, about, template, check, compress, codes, generate, search, decode, sections, help)
  License:            CC BY-SA 4.0

EOF
    return 0
  fi

  # Links-only output
  if ((show_links)); then
    cat <<'EOF'

=== Bash Coding Standard Links ===

Documentation:
  • Main standard:    BASH-CODING-STANDARD.md
  • Repository:       https://github.com/OkusiAssociates/bash-coding-standard
  • FAQ/Rebuttals:    REBUTTALS-FAQ.md
  • Future plans:     FUTURE-SUBCOMMANDS.md

Organizations:
  • Okusi Associates: https://okusiassociates.com
  • YaTTI:            https://yatti.id

References:
  • Google Shell Style Guide:    https://google.github.io/styleguide/shellguide.html
  • ShellCheck:                  https://www.shellcheck.net/
  • Bash Reference Manual:       https://www.gnu.org/software/bash/manual/bash.html
  • Advanced Bash-Scripting:     https://tldp.org/LDP/abs/html/

License:
  • CC BY-SA 4.0:                https://creativecommons.org/licenses/by-sa/4.0/

EOF
    return 0
  fi

  # Default output (with verbose adding stats and links)
  cat <<EOF

Bash Coding Standard (BCS) v$BCS_VERSION

A comprehensive coding standard for modern Bash 5.2+ scripts, designed for
consistency, robustness, and maintainability.

"This isn't just a coding standard - it's a systems engineering philosophy
applied to Bash." -- Biksu Okusi

Coding Principles:
  • K.I.S.S. (Keep It Simple, Stupid)
  • "The best process is no process"
  • "Everything should be made as simple as possible, but not any simpler."

Quick Stats:
  $sections_count sections  |  $rules_count BCS rules  |  $lines_count lines  |  $test_files_count test files

Developed by:  Okusi Associates (https://okusiassociates.com)
Adopted by:    Indonesian Open Technology Foundation (YaTTI)
License:       CC BY-SA 4.0
Repository:    https://github.com/OkusiAssociates/bash-coding-standard

Learn more:  bcs help
View standard: bcs display

EOF

  # If verbose, add stats and links
  if ((show_verbose)); then
    echo '---'
    cmd_about --stats
    echo '---'
    cmd_about --links
  fi

  return 0
}
declare -fx cmd_about

# Generate script templates
cmd_template() {
  # Parse arguments
  local -- template_type='basic'
  local -- script_name=''
  local -- description='Script description'
  local -- version='1.0.0'
  local -- output_file=''
  local -i make_executable=0
  local -i force_overwrite=0

  while (($#)); do
    case $1 in
      -h|--help)
        cat <<'EOF'
bcs template - Generate BCS-compliant script templates

Usage: bcs template [OPTIONS]

Options:
  -h, --help              Show this help message
  -t, --type TYPE         Template type: minimal, basic, complete, library (default: basic)
  -n, --name NAME         Script name (sanitized to valid identifier for {{NAME}} placeholder)
  -d, --description DESC  Script description (default: 'Script description')
  -v, --version VERSION   Version string (default: '1.0.0')
  -o, --output FILE       Output file (default: stdout)
  -x, --executable        Make output file executable (chmod +x)
  -f, --force             Overwrite existing output file

Template types:
  minimal   - Bare essentials (~13 lines)
              • set -euo pipefail
              • error() and die() functions
              • main() function

  basic     - Standard with metadata (~27 lines)
              • Includes everything in minimal
              • Script metadata (VERSION, SCRIPT_PATH, etc.)
              • _msg() helper function
              • readonly declarations

  complete  - Complete with all utilities (~104 lines)
              • Includes everything in basic
              • Colors support
              • Full messaging suite (vecho, success, warn, info, debug)
              • Argument parsing (--help, --version, --verbose, --quiet, --debug)
              • yn() prompt function

  library   - Sourceable library pattern (~38 lines)
              • Library metadata (prefixed with {{NAME}}_)
              • Exported functions (declare -fx)
              • Initialization function
              • No set -e (doesn't modify caller's shell)

Note: Names are automatically sanitized to valid bash identifiers. Special
      characters (hyphens, dots, etc.) are converted to underscores. For example,
      'my-script.v2' becomes 'my_script_v2' in the generated template.

Examples:
  bcs template                                        # Generate basic template to stdout
  bcs template -t complete -n myscript -o myscript.sh # Create complete template
  bcs template -t minimal -o test.sh -x               # Create minimal, make executable
  bcs template -t library -n mylib -o mylib.sh        # Create library template
  bcs template -t complete -n deploy -d 'Deploy application' -v '2.0.0' -o deploy.sh -x

EOF
        return 0
        ;;
      -t|--type)
        arg2 "$@"; shift; template_type="$1"
        ;;
      -n|--name)
        arg2 "$@"; shift; script_name="$1"
        ;;
      -d|--description)
        arg2 "$@"; shift; description="$1"
        ;;
      -v|--version)
        arg2 "$@"; shift; version="$1"
        ;;
      -o|--output)
        arg2 "$@"; shift; output_file="$1"
        ;;
      -x|--executable)
        make_executable=1
        ;;
      -f|--force)
        force_overwrite=1
        ;;
      *)
        error "Unknown option ${1@Q}"
        return 2
        ;;
    esac
    shift
  done

  # Validate template type
  case "$template_type" in
    minimal|basic|complete|library) ;;
    *)
      error "Invalid template type '$template_type'"
      error 'Must be one of: minimal, basic, complete, library'
      return 2
      ;;
  esac

  # Determine script name from output file if not specified
  if [[ -z "$script_name" ]]; then
    if [[ -n "$output_file" ]]; then
      script_name=$(basename -- "$output_file" .sh)
    else
      script_name='script'
    fi
  fi

  # Sanitize script name to valid bash identifier
  # Converts special characters to underscores for use in variable names
  local -- original_name="$script_name"
  script_name=$(post_slug "$script_name" '_' 1 255)

  # Warn if name was changed
  if [[ "$original_name" != "$script_name" ]]; then
    info "Sanitized name: ${original_name@Q} → ${script_name@Q}"
  fi

  # Find templates directory
  local -- data_dir templates_dir
  data_dir=$(find_data_dir) || { error 'Data directory not found'; return 1; }
  templates_dir="$data_dir"/templates
  if [[ ! -d "$templates_dir" ]]; then
    error "Templates directory not found ${templates_dir@Q}"
    return 1
  fi

  # Find template file
  local -- template_file="$templates_dir"/"$template_type".sh.template
  if [[ ! -f "$template_file" ]]; then
    error "Template file not found ${template_file@Q}"
    return 1
  fi

  # Check if output file exists (unless forcing or stdout)
  if [[ -n "$output_file" && "$output_file" != '/dev/stdout' ]]; then
    if [[ -f "$output_file" && $force_overwrite == 0 ]]; then
      error "Output file already exists ${output_file@Q}"
      error 'Use --force to overwrite'
      return 1
    fi
  fi

  # Determine final output destination
  local -- output_dest="${output_file:-/dev/stdout}"

  # Read template and perform substitutions
  local -- content
  content=$(cat "$template_file")

  # Perform placeholder substitutions
  content="${content//\{\{NAME\}\}/$script_name}"
  content="${content//\{\{DESCRIPTION\}\}/$description}"
  content="${content//\{\{VERSION\}\}/$version}"

  # Write output
  if [[ "$output_dest" == '/dev/stdout' ]]; then
    echo "$content"
  else
    echo "$content" > "$output_dest"
    info "Generated $template_type template '$output_dest'"

    # Make executable if requested
    if ((make_executable)); then
      chmod +x "$output_dest"
      info "Made executable ${output_dest@Q}"
    fi
  fi

  return 0
}
declare -fx cmd_template

# Check script compliance using AI
cmd_check() {
  # === SECTION 1: Variable Initialization ===
  local -- script_file=''
  local -- output_format='text'
  local -- tier
  tier=$(get_default_tier)  # Use symlink to determine default tier
  local -- codes_option=''
  local -- sections_option=''
  local -- append_prompt=''
  local -- allowed_tools=''
  local -- add_dir=''
  local -- severity='all'
  local -- claude_cmd='claude'
  local -i strict=0
  local -i skip_permissions=0

  # === SECTION 2: Argument Parsing ===
  while (($#)); do
    case $1 in
      -h|--help)
        cat <<'EOF'
bcs check - Validate bash script against BASH-CODING-STANDARD.md

Usage: bcs check [OPTIONS] SCRIPT_FILE

Core Options:
  -h, --help              Show this help message
  -s, --strict            Strict mode (warnings become violations)
  -f, --format FORMAT     Output format: text|json|markdown|bcs-json
  -q, --quiet             Suppress non-error output

Filtering Options (Token Optimization):
  --codes CODE1,CODE2     Validate only specific BCS codes
                          Examples: BCS01,BCS0205 or 01,0205
  --sections N1,N2        Validate only specific sections (1-14)
                          Example: --sections 1,2,8
  --tier TIER             Documentation tier (default: abstract)
                          Options: abstract (fast), complete (thorough),
                                   summary (brief), rulet (ultra-concise)

Advanced Claude Options:
  --claude-cmd CMD        Custom Claude command (default: claude)
  --append-prompt TEXT    Additional system prompt context
  --allowed-tools TOOLS   Restrict Claude tools (comma-separated)
                          Example: --allowed-tools Read,Grep
  --add-dir PATH          Add directory for Claude context
  --skip-permissions      Skip permission checks (sandbox mode)

Output Control:
  --severity LEVEL        Filter by severity: all|violations|warnings
                          (default: all)

Description:
  Uses Claude AI to validate bash scripts against BASH-CODING-STANDARD.md.

  Token Optimization: By default uses abstract tier (~500 lines) for fast
  validation. Use --tier complete for thorough checks (~3,285 lines), --tier
  rulet for ultra-concise rules (~280 lines), or filter by --codes/--sections
  to validate specific rules only.

Output Formats:
  text      - Human-readable with symbols (✓ ✗ ⚠ 💡)
  json      - Basic JSON structure
  markdown  - Formatted report with sections
  bcs-json  - Structured JSON with BCS code references

Exit Codes:
  0 - Script is compliant (no violations or warnings)
  1 - Script has warnings only (or violations in non-strict mode)
  2 - Script has violations (always in strict mode)

Examples:
  # Quick validation (abstract tier, ~500 lines)
  bcs check myscript.sh

  # Validate only script structure rules
  bcs check --sections 1 myscript.sh

  # Thorough validation of specific codes
  bcs check --codes BCS01,BCS08 --tier complete myscript.sh

  # CI/CD mode: strict, quiet, violations only
  bcs check --strict --quiet --severity violations deploy.sh

  # JSON output for parsing
  bcs check --format bcs-json myscript.sh > report.json

  # Add project context
  bcs check --add-dir ./lib myscript.sh

  # Comprehensive check with all rules
  bcs check --tier complete --strict myscript.sh

Requirements:
  Requires 'claude' CLI (Claude Code) to be installed and available in PATH.
  Get Claude Code at: https://claude.ai/code

EOF
        return 0
        ;;

      -s|--strict)
        strict=1 ;;

      -f|--format)
        arg2 "$@"; shift
        output_format="$1"
        # Validate format
        case $output_format in
          text|json|markdown|bcs-json) ;;
          *)
            error "Invalid output format ${output_format@Q}"
            info 'Must be one of: text, json, markdown, bcs-json'
            return 2
            ;;
        esac
        ;;

      --codes)
        arg2 "$@"; shift
        codes_option="$1"
        ;;

      --sections)
        arg2 "$@"; shift
        sections_option="$1"
        ;;

      --tier)
        arg2 "$@"; shift
        tier="$1"
        # Validate tier
        case $tier in
          abstract|complete|summary|rulet) ;;
          *)  error "Invalid tier '$tier'"
              info 'Must be one of: abstract, complete, summary, rulet'
              return 2
              ;;
        esac
        ;;

      --append-prompt)
        arg2 "$@"; shift
        append_prompt="$1"
        ;;

      --allowed-tools)
        arg2 "$@"; shift
        allowed_tools="$1"
        ;;

      --add-dir)
        arg2 "$@"; shift
        add_dir="$1"
        [[ -d "$add_dir" ]] || { error "Directory not found '$add_dir'"; return 1; }
        ;;

      --skip-permissions)
        skip_permissions=1
        ;;

      --severity)
        arg2 "$@"; shift
        severity="$1"
        case "$severity" in
          all|violations|warnings) ;;
          *)
            error "Invalid severity '$severity'"
            info 'Must be one of: all, violations, warnings'
            return 2
            ;;
        esac
        ;;

      --claude-cmd)
        arg2 "$@"; shift
        claude_cmd="$1"
        ;;

      -v|--verbose)
        VERBOSE+=1 ;;

      -q|--quiet)
        VERBOSE=0 ;;

      --)
        shift
        (($#)) && script_file="$1"
        break
        ;;

      -[sfvq]*) #shellcheck disable=SC2046 #split up single options
        set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}";;

      -*)
        error "Invalid option ${1@Q}";
        info "Use 'bcs check --help' for usage information"
        return 22
        ;;

      *)
        script_file="$1"
        ;;
    esac
    shift
  done

  # === SECTION 3: Validation ===
  [[ -n "$script_file" ]] || {
    error 'No script file specified'
    info  'Usage: bcs check [OPTIONS] SCRIPT_FILE'
    return 2
  }

  [[ -f "$script_file" ]] || { error "Script file not found ${script_file@Q}'"; return 1; }

  [[ -r "$script_file" ]] || { error "Script file not readable ${script_file@Q}"; return 1; }

  # Check Claude availability
  if ! command -v "$claude_cmd" &>/dev/null; then
    error "Claude CLI not found ${claude_cmd@Q}"
    info  'Please install Claude Code from: https://claude.ai/code' \
          'Or specify alternative command with --claude-cmd'
    return 127
  fi

  # Validate mutually exclusive options
  if [[ -n "$codes_option" && -n "$sections_option" ]]; then
    error 'Options --codes and --sections are mutually exclusive'
    return 2
  fi

  # === SECTION 4: Filter Processing ===
  local -a filters=()

  if [[ -n "$codes_option" ]]; then
    info "Filtering by codes ${codes_option@Q}"
    # Parse and validate codes
    local -a parsed_codes=()
    readarray -t parsed_codes < <(parse_codes_option "$codes_option") || {
      error 'Failed to parse BCS codes'
      return 2
    }
    filters=("${parsed_codes[@]}")
  elif [[ -n "$sections_option" ]]; then
    info "Filtering by sections: $sections_option"
    # Convert sections to code prefixes
    local -a parsed_sections=()
    readarray -t parsed_sections < <(parse_sections_option "$sections_option") || {
      error 'Failed to parse sections'
      return 2
    }
    filters=("${parsed_sections[@]}")
  fi

  # === SECTION 5: Prompt Construction ===
  info "Building validation prompt (tier: $tier)..."

  local -- temp_prompt=''
  temp_prompt=$(mktemp) || { error 'Failed to create temporary file'; return 1; }
  trap 'rm -f "${temp_prompt:-}"' RETURN

  # Build system prompt with filtering
  if ((${#filters[@]} > 0)); then
    build_validation_prompt "$tier" "$output_format" "${filters[@]}" > "$temp_prompt"
  else
    build_validation_prompt "$tier" "$output_format" > "$temp_prompt"
  fi

  local -i prompt_lines prompt_bytes
  prompt_lines=$(wc -l < "$temp_prompt")
  prompt_bytes=$(wc -c < "$temp_prompt")
  info "Generated prompt: $prompt_lines lines, $prompt_bytes bytes"

  # === SECTION 6: Claude Command Construction ===
  info 'Preparing Claude command...'

  local -a claude_args=()
  readarray -t claude_args < <(build_claude_command \
    "$temp_prompt" \
    "$append_prompt" \
    "$allowed_tools" \
    "$add_dir" \
    "$skip_permissions" \
    "$claude_cmd"
  )

  # === SECTION 7: Claude Invocation ===
  info "Validating script ${script_file@Q}"

  local -- validation_output
  local -i claude_exit=0

  # Pipe script to Claude
  validation_output=$("${claude_args[@]}" < "$script_file" 2>&1) || claude_exit=$?

  if ((claude_exit)); then
    error "Claude validation failed (exit code $claude_exit)"
    >&2 echo "$validation_output"
    return $claude_exit
  fi

  # === SECTION 8: Output Processing ===
  # Parse output for violations/warnings count
  local -i violations=0
  local -i warnings=0

  case "$output_format" in
    bcs-json|json)
      # Parse JSON for counts
      if command -v jq &>/dev/null; then
        violations=$(jq -r '.summary.violations_count // .summary.violations // 0' <<< "$validation_output" 2>/dev/null) || violations=0
        warnings=$(jq -r '.summary.warnings_count // .summary.warnings // 0' <<< "$validation_output" 2>/dev/null) || warnings=0
      else
        # Fallback: count text markers in JSON
        violations=$(grep -c '"severity"[[:space:]]*:[[:space:]]*"critical"' <<< "$validation_output" 2>/dev/null) || violations=0
        warnings=$(grep -c '"severity"[[:space:]]*:[[:space:]]*"warning"' <<< "$validation_output" 2>/dev/null) || warnings=0
      fi
      ;;
    *)
      # Count markers in text output
      violations=$(grep -c '^✗ VIOLATION:' <<< "$validation_output" 2>/dev/null) || violations=0
      warnings=$(grep -c '^⚠ WARNING:' <<< "$validation_output" 2>/dev/null) || warnings=0
      ;;
  esac

  # Filter output by severity if requested
  case "$severity" in
    violations)
      # Show only violations
      if [[ $output_format == bcs-json || $output_format == json ]]; then
        if command -v jq &>/dev/null; then
          jq 'del(.findings.warnings, .findings.suggestions) | del(.warnings, .suggestions)' <<< "$validation_output" 2>/dev/null || echo "$validation_output"
        else
          grep -E '"severity"[[:space:]]*:[[:space:]]*"critical"' <<< "$validation_output" || echo "$validation_output"
        fi
      else
        grep -E '^✗ VIOLATION:' <<< "$validation_output" || true
      fi
      ;;
    warnings)
      # Show only warnings
      if [[ $output_format == bcs-json || $output_format == json ]]; then
        if command -v jq &>/dev/null; then
          jq 'del(.findings.violations, .findings.suggestions) | del(.violations, .suggestions)' <<< "$validation_output" 2>/dev/null || echo "$validation_output"
        else
          grep -E '"severity"[[:space:]]*:[[:space:]]*"warning"' <<< "$validation_output" || echo "$validation_output"
        fi
      else
        grep -E '^⚠ WARNING:' <<< "$validation_output" || true
      fi
      ;;
    all)
      # Show everything
      echo "$validation_output"
      ;;
  esac

  # === SECTION 9: Exit Code Determination ===
  local -i exit_code=0

  if ((violations > 0)); then
    if ((strict)); then
      exit_code=2  # Violations always return 2 in strict mode
      error "Validation failed: $violations violation$(s $violations) found"
    else
      exit_code=1  # Violations return 1 in normal mode
      warn "Validation issues: $violations violation$(s $violations) found"
    fi
  elif ((warnings)); then
    if ((strict)); then
      exit_code=2  # Warnings become violations in strict mode
      error "Validation failed: $warnings warning$(s $warnings) found (strict mode)"
    else
      exit_code=1  # Warnings return 1 in normal mode
      warn "Validation issues: $warnings warning$(s $warnings) found"
    fi
  else
    exit_code=0  # Clean validation
    success 'Script is compliant with BCS'
  fi

  return "$exit_code"
}
declare -fx cmd_check

# Compress BCS rules using AI
cmd_compress() {
  # Parse arguments
  local -- tier=''
  local -- claude_cmd='claude'
  local -- context_level='none'  # Default: no context
  local -i dry_run=0
  local -i compress_verbose=1
  local -i regenerate=0
  local -i force=0
  local -i report_only=1  # Default mode
  local -i summary_limit=10000
  local -i abstract_limit=1500

  while (($#)); do
    case $1 in
      -h|--help)
        cat <<'EOF'
bcs compress - Compress BCS rules using Claude AI (Developer Mode)

Usage: bcs compress [OPTIONS]

MODES:
  --report-only        Report oversized files only (default)
  --regenerate         Delete and regenerate all compressed files

OPTIONS:
  --tier TIER            Process specific tier: summary or abstract (default: both)
  --force                Force regeneration even if timestamps match (use with --regenerate)
  --claude-cmd CMD       Claude CLI command path (default: claude)
  --summary-limit N      Summary file size limit in bytes (default: 10000)
  --abstract-limit N     Abstract file size limit in bytes (default: 1500)
  --context-level LEVEL  Context awareness level (default: none)
                         • none: No additional context (fastest, cheapest)
                         • toc: Table of contents only (~5-10KB context)
                         • abstract: Full abstract standard (~83KB context)
                         • summary: Full summary standard (~310KB context)
                         • complete: Full complete standard (~520KB context)
  -n, --dry-run          Show what would be done without doing it
  -q, --quiet            Quiet mode (less verbose output)
  -v, --verbose          Verbose mode (default)
  -h, --help             Show this help message

DESCRIPTION:
  Uses Claude AI to automatically compress .complete.md rule files to
  .summary.md and .abstract.md tiers while preserving technical accuracy.

  This command enables "Developer Mode" features for managing custom rules
  and maintaining multi-tier documentation.

MODES IN DETAIL:
  --report-only (default)
    • Lists all files exceeding size limits by tier
    • No modifications made to files
    • Quick overview of compression needs
    • Backward compatible with original behavior

  --regenerate
    • Deletes existing compressed files
    • Regenerates all .summary.md and .abstract.md files from .complete.md
    • Skips files where all three tiers have matching timestamps (unless --force used)
    • Uses Claude AI with specialized compression prompts
    • Syncs timestamps across all three tiers
    • Automatic retry with stricter prompts for oversized files

  --force (use with --regenerate)
    • Forces regeneration even when timestamps match
    • Touches all .complete.md files to trigger regeneration
    • Useful when changing compression prompts or context levels
    • Ensures all files are reprocessed regardless of timestamp

SIZE LIMITS:
  complete:  20000 bytes (informational only, not enforced)
  summary:   10000 bytes (default, adjustable with --summary-limit)
  abstract:  1500 bytes (default, adjustable with --abstract-limit)

CONTEXT LEVELS:
  Understanding context awareness for better compression:

  --context-level none (default, fastest)
    • Each rule compressed in isolation
    • No awareness of other rules
    • Fastest, lowest token cost
    • Use for: Testing, quick iterations

  --context-level toc (lightweight)
    • Includes table of contents + section summaries (~5-10KB)
    • Structural awareness of what exists elsewhere
    • Minimal token cost
    • Use for: Moderate improvement with low overhead

  --context-level abstract (recommended for most cases)
    • Includes full BASH-CODING-STANDARD.abstract.md (~83KB)
    • Full awareness of all other rules for cross-reference
    • Can identify and eliminate cross-rule duplication
    • Maintains consistent terminology across standard
    • Good balance of context vs token cost
    • Use for: Production regeneration, final compression

  --context-level summary (detailed context)
    • Includes full BASH-CODING-STANDARD.summary.md (~310KB)
    • More detailed context than abstract tier
    • Useful when compressing to abstract tier with rich examples
    • Higher token cost than abstract context
    • Use for: When abstract context isn't detailed enough

  --context-level complete (maximum context)
    • Includes full BASH-CODING-STANDARD.complete.md (~520KB)
    • Most comprehensive context with all examples and rationale
    • Highest token cost, slowest processing
    • Use for: Complex rules requiring full documentation context
    • Consider if results justify the token cost

EXAMPLES:
  # Report oversized files (current behavior)
  bcs compress
  bcs compress --report-only

  # Regenerate with abstract context (recommended)
  bcs compress --regenerate --context-level abstract

  # Regenerate without context (fastest)
  bcs compress --regenerate --context-level none

  # Regenerate with TOC context (lightweight)
  bcs compress --regenerate --context-level toc

  # Regenerate with summary context (more detailed)
  bcs compress --regenerate --context-level summary

  # Regenerate with complete context (maximum detail)
  bcs compress --regenerate --context-level complete

  # Regenerate only summary files (dry-run)
  bcs compress --regenerate --tier summary --dry-run

  # Production regeneration (recommended settings)
  bcs compress --regenerate --context-level abstract --verbose

  # Force regeneration (ignore timestamps)
  bcs compress --regenerate --force --context-level abstract

  # Use custom Claude command and limits
  bcs compress --regenerate --context-level abstract \
    --claude-cmd /usr/local/bin/claude \
    --abstract-limit 1200 --summary-limit 8000

  # Quiet mode for automation
  bcs compress --regenerate --context-level abstract --quiet

REQUIREMENTS:
  Requires 'claude' CLI (Claude Code) to be installed and available in PATH.
  Get Claude Code at: https://claude.ai/code

WORKFLOW:
  1. Edit .complete.md files with full documentation
  2. Run: bcs compress --regenerate
  3. Review compression statistics
  4. Run: bcs generate --canonical
  5. Commit all three tiers to repository

NOTE: This is a developer mode feature for managing custom BCS rules and
      maintaining the multi-tier documentation system.

EOF
        return 0
        ;;

      --report-only)
        report_only=1
        regenerate=0
        ;;

      --regenerate)
        regenerate=1
        report_only=0
        ;;

      -f|--force)
        force=1
        ;;

      --tier)
        arg2 "$@"; shift
        tier="$1"
        [[ "$tier" =~ ^(summary|abstract)$ ]] || {
          error "Invalid tier: $tier (must be 'summary' or 'abstract')"
          return 2
        }
        ;;

      --claude-cmd)
        arg2 "$@"; shift
        claude_cmd="$1"
        ;;

      --summary-limit)
        arg2_num "$@"; shift
        summary_limit="$1"
        ;;

      --abstract-limit)
        arg2_num "$@"; shift
        abstract_limit="$1"
        ;;

      --context-level)
        arg2 "$@"; shift
        context_level="$1"
        [[ "$context_level" =~ ^(none|toc|abstract|summary|complete)$ ]] || {
          error "Invalid context level: $context_level (must be 'none', 'toc', 'abstract', 'summary', or 'complete')"
          return 2
        }
        ;;

      -n|--dry-run)
        dry_run=1
        ;;

      -v|--verbose)
        compress_verbose=1
        ;;

      -q|--quiet)
        compress_verbose=0
        ;;

      -[nvqhf]*) #shellcheck disable=SC2046
        set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}"
        ;;

      -*)
        error "Invalid option ${1@Q}"
        info "Use 'bcs compress --help' for usage information"
        return 2
        ;;

      *)
        error "Unexpected argument: $1"
        return 2
        ;;
    esac
    shift
  done

  # Find data directory
  local -- data_dir
  data_dir=$(find_data_dir) || { error 'Data directory not found'; return 1; }

  # Verify data directory exists
  [[ -d "$data_dir" ]] || { error "Data directory not found: $data_dir"; return 1; }

  # Report-only mode
  if ((report_only)); then
    ((compress_verbose)) && info 'Report-only mode: listing oversized files'
    compress_report_oversized_files "$data_dir" 20000 "$summary_limit" "$abstract_limit"
    return 0
  fi

  # Regenerate mode
  ((dry_run)) && ((compress_verbose)) && info 'DRY-RUN mode enabled - no changes will be made'
  ((compress_verbose)) && info 'Regenerate mode: will delete and recreate compressed files'

  # Validate Claude CLI
  compress_validate_claude_cli "$claude_cmd" || return 1

  # Process all rules
  compress_process_all_rules "$data_dir" "$tier" "$claude_cmd" "$dry_run" \
    "$compress_verbose" "$summary_limit" "$abstract_limit" "$context_level" "$force"

  # Show statistics (note: this is a simplified version - full stats tracking
  # would require modifying the helper functions to return statistics)
  ((compress_verbose)) && >&2 echo
  ((compress_verbose)) && success 'Compression processing complete'

  if ((dry_run)); then
    ((compress_verbose)) && info 'Dry-run complete - review output and run without --dry-run to execute'
  else
    ((compress_verbose)) && >&2 echo
    ((compress_verbose)) && info 'Next steps:' \
      '  1. Review any oversized files listed above' \
      '  2. Manually compress critical oversized files if needed' \
      '  3. Run: bcs generate --canonical'
  fi

  return 0
}
declare -fx cmd_compress

# Show help information
cmd_help() {
  local -- topic="${1:-}"

  # If topic specified, delegate to subcommand help
  if [[ -n "$topic" ]]; then
    case "$topic" in
      display)
        cmd_display --help
        ;;
      codes)
        cmd_codes --help
        ;;
      generate)
        cmd_generate --help
        ;;
      generate-rulets)
        cmd_generate_rulets --help
        ;;
      search)
        cmd_search --help
        ;;
      decode)
        cmd_decode --help
        ;;
      sections)
        cmd_sections --help
        ;;
      about)
        cmd_about --help
        ;;
      template)
        cmd_template --help
        ;;
      check)
        cmd_check --help
        ;;
      compress)
        cmd_compress --help
        ;;
      default)
        cmd_default --help
        ;;
      *)
        error "Unknown command '$topic'"
        info "Run 'bcs help' for list of commands"
        return 2
        ;;
    esac
    return 0
  fi

  # Show top-level help
  cat <<'EOF'
bcs - Bash Coding Standard toolkit

Usage: bcs [COMMAND] [OPTIONS] [ARGS]

Commands:
  display            Display the Bash Coding Standard
  about              Display project information and statistics
  template           Generate BCS-compliant script templates
  check              AI-powered script compliance checker
  compress           Compress BCS rules using Claude AI
  codes              List all BCS rule codes with titles
  generate           Regenerate standard from data/ tree
  generate-rulets    Generate rulet files from complete.md rulefiles
  search PATTERN     Search within the standard
  decode CODE        Decode BCS code to file location or content
  sections           List all sections of the standard
  default [TIER]     Set or show the default tier
  help [COMMAND]     Show help for a command

Global Options:
  -h, --help         Show help information
  -V, --version      Show version information

Examples:
  bcs                                    # Display the standard
  bcs about                              # Show project information
  bcs about --stats                      # Show statistics only
  bcs template -t complete -o test.sh    # Generate complete template
  bcs check myscript.sh                  # Check script compliance with AI
  bcs compress --regenerate              # Regenerate compressed rule files
  bcs -c                                 # Display using cat (backward compat)
  bcs codes                              # List all BCS codes
  bcs search readonly                    # Search for "readonly"
  bcs decode BCS010201 -p                # View dual-purpose pattern rule
  bcs decode BCS010201                   # Show file location for BCS010201
  bcs generate --canonical               # Regenerate canonical standard
  bcs generate-rulets --all              # Generate rulets for all categories
  bcs sections                           # List all 14 sections
  bcs default                            # Show current default tier
  bcs default complete                   # Set default to complete tier
  bcs default --list                     # List all available tiers
  bcs help check                         # Show help for check command

For detailed help on a command, use:
  bcs help COMMAND
  bcs COMMAND --help

EOF
  return 0
}
declare -fx cmd_help

cmd_display() {
  if [[ -z "$BCS_FILE" ]]; then
    # BCS_PATH may already be set and readonly from script initialization
    local -- path
    path="${BCS_PATH:-$(realpath -- "${BASH_SOURCE[0]}")}"
    BCS_FILE=$(find_bcs_file "${path%/*}") || {
      error 'BASH-CODING-STANDARD.md not found when sourcing'
      return 1
    }
    BCS_MD=''
  fi

  # Local variables for argument parsing
  local -i force_cat=0 force_bash=0 force_md2ansi=0 force_json=0 squeeze_blanks=0
  local -a viewer_args=()

  # Parse command-line arguments
  while (($#)); do
    case $1 in
      -h|--help)    cat <<'EOF'
bash-coding-standard - (bcs) Display the Bash Coding Standard

Usage: bcs [OPTIONS] [SUB-COMMAND] [VIEWER_OPTIONS]

Options:
  -h, --help           Show this help message
  -V, --version        Show version information
  -s, --squeeze        Squeeze consecutive blank lines (uses cat -s)

Sub-commands (mutually exclusive - only one allowed):
  -c, --cat            Force cat output (bypass md2ansi rendering)
  -b, --bash           Export BCS_MD as bash variable declaration
  -a, --md2ansi        Force md2ansi output
  -j, --json           Output as JSON format

Any additional arguments are passed to the viewer command (cat or md2ansi).

Examples:
  bcs              # Display with auto-detection
  bcs -c           # Force plain text output
  bcs --cat        # Same as -c
  bcs --json       # Output as JSON
  bcs -s           # Squeeze consecutive blank lines
  bcs --cat -n     # Pass -n to cat (line numbers)
  source bcs       # Load cmd_display function
EOF
                    return 0
                    ;;
      -V|--version) echo "bcs $BCS_VERSION"
                    return 0
                    ;;
      -c|--cat|-)   force_cat=1
                    ;;
      -s|--squeeze) squeeze_blanks=1
                    ;;
      -b|--bash)
                    force_bash=1
                    ;;
      -a|--md2ansi)
                    force_md2ansi=1
                    ;;
      -j|--json)
                    force_json=1
                    ;;
      -[hVcsbaj]*) #shellcheck disable=SC2046 #split up combined short options
                    set -- '' $(printf -- '-%c ' $(grep -o . <<<"${1:1}")) "${@:2}"
                    ;;
      -*)           viewer_args+=("$1")
                    ;;
      *)            error "Too many arguments ${1@Q}"
                    return 2
                    ;;
    esac
    shift
  done

  # Validate that at most one sub-command was specified
  local -i subcommand_count=$((force_cat + force_bash + force_json + force_md2ansi))
  if ((subcommand_count > 1)); then
    error 'Multiple sub-commands specified'
    info 'Only one of -c, -b, -j, -a may be used at a time'
    return 2
  fi

  # Execute based on parsed flags
  if ((force_json)); then
    # Use jq if available for proper JSON encoding, otherwise manual escape
    if command -v jq &>/dev/null; then
      jq -Rs '{("bcs"): .}' -- "$BCS_FILE"
    else
      # Manual JSON string escaping
      local -- content
      content=$(cat -- "$BCS_FILE")
      # Escape backslashes, quotes, and control characters
      content="${content//\\/\\\\}"     # Escape backslashes first
      content="${content//\"/\\\"}"     # Escape double quotes
      content="${content//$'\n'/\\n}"   # Escape newlines
      content="${content//$'\r'/\\r}"   # Escape carriage returns
      content="${content//$'\t'/\\t}"   # Escape tabs
      content="${content//$'\f'/\\f}"   # Escape form feeds
      content="${content//$'\b'/\\b}"   # Escape backspaces
      printf '{\"bcs\":\"%s\"}\n' "$content"
    fi
    return 0

  elif ((force_bash)); then
    declare -gx BCS_MD
    ((squeeze_blanks)) && BCS_MD="$(cat -s "${viewer_args[@]}" -- "$BCS_FILE")" \
                       || BCS_MD="$(cat "${viewer_args[@]}" -- "$BCS_FILE")"
    declare -p BCS_MD
    return 0

  elif ((force_cat)); then
    #shellcheck disable=SC2015  # False positive: cat always returns 0
    ((squeeze_blanks)) && cat -s "${viewer_args[@]}" -- "$BCS_FILE" \
                       || cat "${viewer_args[@]}" -- "$BCS_FILE"
    return 0
  # Use md2ansi for formatted output if available and outputting to terminal
  elif ((force_md2ansi)) || [[ -t 1 ]]; then
    local -- md2ansi_cmd
    md2ansi_cmd=$(find_md2ansi) || md2ansi_cmd=''
    if [[ -n "$md2ansi_cmd" ]]; then
      "$md2ansi_cmd" "${viewer_args[@]}" -- "$BCS_FILE" | less -FXRS
      return 0
    fi
  fi

  # final fall back to cat
  #shellcheck disable=SC2015  # False positive: cat always returns 0
  ((squeeze_blanks)) && cat -s "${viewer_args[@]}" -- "$BCS_FILE" \
                     || cat "${viewer_args[@]}" -- "$BCS_FILE"
  return 0
}
declare -fx cmd_display

# ============================================================================
# Dual-Purpose Script Pattern (BCS010201)
# ============================================================================
# This script can be executed OR sourced for library functions
#
# When SOURCED:
#   - All cmd_* functions become available to caller
#   - BCS_MD variable pre-loaded with standard content
#   - Returns immediately (no main() execution)
#   - Does NOT modify caller's shell options (no set -e)
#
# When EXECUTED:
#   - Strict mode enabled (set -euo pipefail)
#   - main() dispatcher runs subcommands
#   - Exits with appropriate status code
#
# NOTE: This implementation uses inverted logic (!= check) instead of the
#       BCS010201 recommended early-return pattern. See CLAUDE.md for details.
# ============================================================================

# Sourced mode ----------------------------------------------------------------
if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
  # Sourced: provide functions and pre-load BCS content
  declare -- BCS_PATH BCS_FILE BCS_MD
  #shellcheck disable=SC2015  # Intentional: handle find success/failure differently
  BCS_FILE=$(find_bcs_file "${BCS_PATH%/*}") && {
    # Auto-initialize BCS_MD if file was found
    BCS_MD="$(cat -- "$BCS_FILE")"
    true
  } || {
    error "BASH-CODING-STANDARD.md not found when sourcing"
    false
  }
  return
fi


# Executed mode - run as standalone script ------------------------------------
# When executed (not sourced), enable strict mode and run main dispatcher
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

main() {
  # Command dispatcher
  # Default to display if no arguments, otherwise use first argument as subcommand
  declare -- subcommand
if (($# == 0)); then
  subcommand='display'
else
  subcommand="$1"
  shift  # Remove subcommand from args
fi

# Handle global options
case "$subcommand" in
  -h|--help)
    cmd_help
    exit 0
    ;;
  -V|--version)
    echo "bcs $BCS_VERSION"
    exit 0
    ;;
esac

# Commands that require BCS_FILE to exist: display, search, sections
# Other commands work directly with data/ directory or don't need the standard file
declare -- BCS_FILE='' install_share="${BCS_DIR%/bin}/share/yatti/bash-coding-standard"
case "$subcommand" in
  display|search|sections)
    # These commands require the standard file
    BCS_FILE=$(find_bcs_file "${BCS_PATH%/*}") || {
      error "BASH-CODING-STANDARD.md not found"
      info  'Searched locations:' \
            "  - $BCS_DIR/BASH-CODING-STANDARD.md" \
            "  - $install_share/BASH-CODING-STANDARD.md" \
            '  - /usr/local/share/yatti/bash-coding-standard/BASH-CODING-STANDARD.md' \
            '  - /usr/share/yatti/bash-coding-standard/BASH-CODING-STANDARD.md'
      exit 1
    }
    ;;
  -*)
    # Backward compatibility for display options (e.g., bcs -c)
    BCS_FILE=$(find_bcs_file "${BCS_PATH%/*}") || {
      error "BASH-CODING-STANDARD.md not found"
      info  'Searched locations:' \
            "  - $BCS_DIR/BASH-CODING-STANDARD.md" \
            "  - $install_share/BASH-CODING-STANDARD.md" \
            '  - /usr/local/share/yatti/bash-coding-standard/BASH-CODING-STANDARD.md' \
            '  - /usr/share/yatti/bash-coding-standard/BASH-CODING-STANDARD.md'
      exit 1
    }
    ;;
esac

# Backward compatibility: if starts with dash, treat as display option
# Note: need to restore the argument for cmd_display
if [[ "$subcommand" == -* ]]; then
  cmd_display "$subcommand" "$@"
  exit $?
fi

# Dispatch to subcommand
case "$subcommand" in
  display)
    cmd_display "$@"
    ;;
  about)
    cmd_about "$@"
    ;;
  template)
    cmd_template "$@"
    ;;
  check)
    cmd_check "$@"
    ;;
  compress)
    cmd_compress "$@"
    ;;
  codes)
    cmd_codes "$@"
    ;;
  generate)
    cmd_generate "$@"
    ;;
  generate-rulets)
    cmd_generate_rulets "$@"
    ;;
  search)
    cmd_search "$@"
    ;;
  decode)
    cmd_decode "$@"
    ;;
  sections)
    cmd_sections "$@"
    ;;
  default)
    cmd_default "$@"
    ;;
  help)
    cmd_help "$@"
    ;;
  *)
    error "Unknown command '$subcommand'"
    info "Try 'bcs help' for usage information"
    exit 2
    ;;
esac
}

main "$@"
#fin
